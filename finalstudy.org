#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
* Pre midterm stuff

** SECD virtual machine
- https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830027
- https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830028


#+begin_example lisp
(lambda (x y) (if (eq x y) x (+ 1 y)))
(LDF
  ( LD (1.2) LD (1.1) EQ SEL (LD (1.1)) (LD (1.2) LDC 1 ADD)
  RTN ))
(LDF (LD (1.2) LD (1.1) EQ SEL (LD (1.1) JOIN) (LD (1.1) ((LD 1.2) LDC 1 + JOIN))
             RTN) )
#+end_example

#+begin_example lisp
(lambda (x y) ((lambda (z) (+ x y z)) 6))
Note that the body of the outside lambda function is an application ((lambda (z) (+ x y z)) 6)),
where the operator + is generic, just like the same operator in lisp.
To decompose the over-all task, you should first show the SECD code for this expression and denote it by, e.g.,e’.
Then, plug it into the full solution.
Answer: e’ = (NIL LDC 6 CONS LDF (LD (2.1) LD (1.2) LD (1.1) ADD RTN) AP)
Then, the full solution is:(LDF e’ || (RTN))
#+end_example

#+begin_example lisp
(lambda (x) ((lambda (z) (+ x x z)) 4))
Note that the body of the outside lambda function is an application((lambda (z) (+ x x z)) 4)).
To decompose the overall task, you should first show the SECD code for this expression anddenote it by, e.g.,e’.
Then, plug it into the full solution.
Answer:(LDF)  (e’ || (RTN)), where e’is
e = (NIL LDC 4 CONS (LDF (LD (2.1) LD (1.1) LD (1.1) ADD RTN) ) AP
#+end_example
** Context based interpreter
#+begin_example lisp
((lambda (f) (f 2 3)) (lambda (x y) (* x (+ y 1))))

context when (f 2 3) is evaluated (initial context is CT0)
{f -> [(lambda (x y) (* x (+ y 1))), CT0]} U CT0

context when (* x (+ y 1)) is evaluated
{x -> 2, y -> 3} U CT0
#+end_example

#+begin_example lisp
eval
    ((lambda (f x) (cons z (f x x))) (lambda (u v) (cons u v)) 5)
in CT0

CT0 = {z -> 2}

context when (cons z (f x x)) is evaluated
A: Let e1 denote(lambda (u v) (cons u v)).
Then, eval(cons z (f x x))in the context{f→[e1, CT0], x→5}∪CT0
where[e1, CT0] denotes the corresponding closure. Denote this context by CT1.

context when(f x x) is evaluated
A: Continuing the above, eval(f x x)in CT1.
Also, eval z in CT1 (not part of thequestion), which yields 2.

context when(cons u v) is evaluated
A: Continuing the above, eval f in CT1 gives [e1, CT0]
and eval(x x)in CT1 gives(5 5)
Now, apply the function ine1and we have eval(cons u v)in the context{u→5, v→5}∪CT0
===
Overall result is
Two applications of cons gives us (2 . (5 . 5)), or you can simplify it to (2 5 . 5).
#+end_example


** Lambda calculus
#+begin_example
truth table practice
Lxy|xNM
if x is true then N else M

x y | output
T T | F
T F | F
F T | F
F F | F
(Lxy|F)

x y | output
T T | F
T F | F
F T | F
F F | T
(Lxy|xF(NOT y)

x y | output
T T | F
T F | F
F T | T
F F | F
(Lxy|xFy)


x y | output
T T | F
T F | F
F T | T
F F | T
(Lxy|xFT)

x y | output
T T | F
T F | T
F T | F
F F | F
(Lxy|yFx)

x y | output
T T | F
T F | T
F T | F
F F | T
(Lxy|yFT)

x y | output
T T | F
T F | T
F T | T
F F | F
(Lxy|x(NOT y)y)

x y | output
T T | F
T F | T
F T | T
F F | T
(Lxy|y(NOT x)T)
(*Lxy|x(NOT y)T)

x y | output
T T | T
T F | F
F T | F
F F | F
(Lxy|xyF)

x y | output
T T | T
T F | F
F T | F
F F | T
(Lxy|xy(NOT y)

x y | output
T T | T
T F | F
F T | T
F F | F
(Lxy|y)

x y | output
T T | T
T F | F
F T | T
F F | T
(Lxy|xyT)

x y | output
T T | T
T F | T
F T | F
F F | F
(Lxy|x)

x y | output
T T | T
T F | T
F T | F
F F | T
(Lxy|xT(NOT y))

x y | output
T T | T
T F | T
F T | T
F F | F
(Lxy|xTy)

x y | output
T T | T
T F | T
F T | T
F F | T
(Lxy|T)
#+end_example

** Lisp
*** Useful functions
#+begin_src lisp
;; useful functions


(defun xmember (X Y)
  (cond
   ((not Y) nil)
   ((equal X (car Y)) t)
   (t (xmember X (cdr Y)))))

(defun xcomplement (S1 S2)
  (cond
    ((null S1) nil)
    ((xmember (car S1) S2) (xcomplement (cdr S1) S2))
    (t (cons (car S1) (xcomplement (cdr S1) S2)))))
(assert (equal (xcomplement '(a b c d e) '(a c)) '(b d e)))

(defun xfilter (test L)
  (cond
    ((null L) nil)
    ((funcall test (car L)) (cons (car L) (xfilter test (cdr L))))
    (t (xfilter test (cdr L)))))

(defun xrotate (L)
  (if (null L) nil
      (append (cdr L) (list (car L)))))
(assert (equal (xrotate '(1 2 3 4)) '(2 3 4 1)))

(cdr '(1 2))
(defun xrotateAll (L)
  (if (atom L) L
      (xrotate (mapcar 'xrotateAll L))))
(assert (equal (xrotateAll '(a b (1 2 3 4) (c d))) '(b (2 3 4 1) (d c) a)))
(assert (equal (xrotateAll '((a b) () (1 2 3 4) c d)) '(nil (2 3 4 1) c d (b a))))
(assert (equal (xrotateAll '(a b nil (1 2 (3 4)))) '(b nil (2 (4 3) 1) a)))

;; it flattens lists with sublists of any depth such that the result is just a list of atoms
;; assumes that NIL will not appear in the list given
;; Test cases (the test-case function is in a comment at the end of this file)
;; (test-case 2.1 (flatten '(a (b c) d)) '(a b c d))
;; (test-case 2.2 (flatten '((((a))))) '(a))
;; (test-case 2.3 (flatten '(a (b c) (d ((e)) f))) '(a b c d e f))
(defun flatten (X)
  (cond
    ((null X) nil)
    ((atom (car X)) (cons (car X) (flatten (cdr X))))
    (t (append (flatten (car X)) (flatten (cdr X))))))

;; it removes duplicate items from a list, preserving the order of elements
;; assumes that NIL will not appear in the list given
;; (test-case 3.1 (remove-duplicate '(a b c a d b)) '(c a d b)) ;abcd is also a valid order
(defun remove-duplicate (X)
  (cond
   ((not X) nil)
   ((xmember (car X) (cdr X)) (remove-duplicates (cdr X)))
   (t (cons (car X) (remove-duplicates (cdr X))))))

;; it mixes the elements of L1 and L2, interweaving them
;; if one list is shorter than the other, append remaining elements to the end
(defun mix (L1 L2)
  (cond
   ((not L2) L1)
   ((not L1) L2)
   (t (cons (car L1) (mix L2 (cdr L1))))))

;; it returns all the subsets of a given set
(defun allsubsets (L)
  (if (null L) (list nil)
    (gen-subsets (car L) (allsubsets (cdr L)))))

;; What does this function do?
;; it generates subsets for a given list
;;
;; How does the function work?
;; I got the algorithm from wikipedia:  https://en.wikipedia.org/wiki/Power_set#Recursive_definition
;; For a non-empty set S (assignment calls it L)
;; let e be any element of the set (car L), which we get from allsubsets above
;; and T is the relative complement of e
;; then the power set of S is a union of a power set of T and
;; a power set of T whose each element is expanded with e
(defun gen-subsets (e Tcomplement)
  (if (not Tcomplement) nil
    (cons
     (cons e (car Tcomplement))
     (cons (car Tcomplement) (gen-subsets e (cdr Tcomplement))))))


;; QUESTION 6
;; Part 1
;;
;; What does this function do?
;; given a list L, which is a list of pairs representing linkage
;; and x, the page to start at
;; it returns a list of all webpages that are reachable if you start at x, and follow links to other pages
;;
;; How does the function work?
;; it finds all the websites that can be reached, then removes duplicate items
;; and also x, if it is present (see remove-x)
;; see find-links
;;
;; Test cases (the test-case function is in a comment at the end of this file)
;; (test-case 6.11 (reached 'google '( (google shopify) (google aircanada) (amazon aircanada))) '(SHOPIFY AIRCANADA))
;; (test-case 6.12 (reached 'google '( (google shopify) (shopify amazon) (amazon google) ) ) '(amazon shopify))
;; (test-case 6.13 (reached 'google '( (google shopify) (shopify amazon) (amazon indigo)  )) '(INDIGO amazon shopify))
;; (test-case 6.14 (reached 'google '( (google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google) ))  '(SHOPIFY delta AIRCANADA))
;; (test-case 6.14 (reached 'google '( (google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google) ))  '(SHOPIFY delta AIRCANADA))
;; ;;backwards reached
;; (test-case 6.15 (reached 'google '((shopify aircanada) (google shopify))) '(aircanada shopify))
;; ;; cycle
;; (test-case 6.16 (reached 'a '((a b) (b a) (a c))) '(b c))
(defun reached (x L)
  (remove-duplicate
   (remove-x x
             (find-links x L L nil))))

;; What does this function do?
;; given x, and a list L, it will remove occurrences of x in L
;;
;; How does the function work?
;; it checks each item in the list, and if x is equal to that item, we ignore it
;; and recurse on (cdr l)
;; otherwise, we include the item, and remove duplicates from the rest of the list
(defun remove-x (x L)
  (cond
   ((null L) nil)
   ((eq x (car L)) (remove-x x (cdr L)))
   (t (cons (car L) (remove-x x (cdr L))))))

;; What does this function do?
;; it finds all of the places that can be reached
;; (see the description for reached)
;; the difference here, is that there can be duplicates,
;; and the starting point x, can also be included in the result
;; in reached, these are removed from the result returned by this function
;;
;; How does the function work?
;; x is the starting point to search
;; L is the given list of links
;; original is the original list of links. It starts out being the same as L,
;;  but because we need to check each pair, we use L to go over each element in the list
;;  and when we need the original list, we pass that in.
;; visited is a list to keep track of websites we have visited
;; if we've already visited the site, then we return nil
;; if we've exhausted all elements, we return x in a list,
;; if there are still items in L, we recursively build that list
;; so the end result contains all of the websites visited
;;
;; (caar L) is the first website in the first element of the list given
;;  e.g. (caar '((a b) (c d))) should give a
;; (cadar L) is the second website in the first element of the list given
;;  e.g. (caar '((a b) (c d))) should give b
;;
;; when recursively building this list, we check if x is equal to (caar L)
;; which means that the website x links to somewhere else
;; we get that using (cadar L) and then recursively find out which
;; websites (cadar L) links to since those can also be reached from x
;;
;; we also search the rest of the list, since x could link to other places later
;; in the list
(defun find-links (x L original visited)
  (cond
   ((null L) (list x)) ; done iteration, ran out of items
   ((xmember x visited) nil)
   ((eq x (caar L)) (append (find-links (cadar L) original original (cons x visited))
                            (find-links x (cdr L) original visited)))
   (t (find-links x (cdr L) original visited))))

;; QUESTION 6
;; Part 2
;;
;; What does this function do?
;; given S, which is a list of websites
;; L, which is a list of pairs representing linkage between websites,
;; this returns a permutation of S, such that the websites
;; with the most links to it is first in the list
;; if 2 pages are equally important, the order does not matter
;; a site referring to itself does not count
;; and a multiple references to a site from another same site only counts once
;;
;; How does the function work?
;; first, we count the references to each site using get-rank (see below)
;; then, we sort it using mySort, which sorts based on the number of references counted
;; finally, we get rid of the counts, and return just the final sorted list of
;; elements that were originally in S
;;
;; Test cases (the test-case function is in a comment at the end of this file)
;; (test-case 6.221 (rank '(google shopify aircanada amazon) '((google shopify) (google aircanada) (amazon aircanada))) '(AIRCANADA SHOPIFY GOOGLE AMAZON))
;; (test-case 6.222 (rank '(google shopify amazon) '((google shopify) (shopify amazon) (amazon google))) '(GOOGLE SHOPIFY AMAZON))
;; (test-case 6.223 (rank '(google shopify amazon indigo) '((google shopify) (shopify amazon) (amazon indigo))) '(SHOPIFY AMAZON INDIGO GOOGLE))
;; (test-case 6.224 (rank '(google shopify aircanada amazon delta) '((google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google))) '(AIRCANADA SHOPIFY DELTA GOOGLE AMAZON))
(defun rank (S L)
  (map-get-cars
   (mySort
    (get-rank S L))))

;; I can't use mapcar for this assignment, so this just
;; goes over each element, and maps each pair to just the first element
;; example: ((1 2) (3 4) (5 6)) becomes (1 3 5)
(defun map-get-cars (L)
  (if (null L) nil
    (cons (caar L) (map-get-cars (cdr L)))))

;; Custom sort function, this function was given to us on eclass
(defun mySort (L)
  (sort L 'greaterThan))

;; Custom sort function, this function was given to us on eclass
;; it sorts such that the item with the greatest second item in the pair comes first
;; I use cdr instead of cadr here because I end up with a list of dotted pairs, so
;; cdr gets me an atom, which is the second item in the pair
(defun greaterThan (L1 L2)
  (> (cdr L1) (cdr L2)))

;; What does this function do?
;; given S, which is a list of websites
;; L, which is a list of pairs representing linkage between websites,
;; this returns a list of pairs, where the first item in the pair comes from list S,
;; and the second item is how many unique links there are to that website
;;
;; How does the function work?
;; for each element in S, we count how many references there are to that element (see count-references)
;; we then take that element and map it to a pair with the first element being itself, and the second
;; element being the result of count-references
;;
;; Test cases (the test-case function is in a comment at the end of this file)
;; (test-case 6.21 (test-rank '(google shopify aircanada amazon) '((google shopify) (google aircanada) (amazon aircanada))) '((AIRCANADA 2) (SHOPIFY 1) (GOOGLE 0) (AMAZON 0)))
;; (test-case 6.22 (test-rank '(google shopify amazon) '((google shopify) (shopify amazon) (amazon google))) '((GOOGLE 1) (SHOPIFY 1) (AMAZON 1)))
;; (test-case 6.23 (test-rank '(google shopify amazon indigo) '((google shopify) (shopify amazon) (amazon indigo))) '((SHOPIFY 1) (AMAZON 1) (INDIGO 1) (GOOGLE 0)))
;; (test-case 6.24 (test-rank '(google shopify aircanada amazon delta) '((google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google))) '((AIRCANADA 2) (SHOPIFY 1) (DELTA 1) (GOOGLE 0) (AMAZON 0)))
;; ;; multiple references don't count and references to self don't count
;; (test-case 6.25 (test-rank '(google shopify aircanada amazon delta) '((google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (aircanada aircanada) (aircanada delta) (google google))) '((AIRCANADA 2) (SHOPIFY 1) (DELTA 1) (GOOGLE 0) (AMAZON 0)))
;;
;; this just makes sure that my test cases match the result that i'm expecting it to be equal to
;; since get-rank returns a list of dotted pairs instead of a list of pairs
;; (defun test-rank (S L)
;;   (mapcar (lambda (x) (list (car x) (cdr x)))
;;           (mySort (get-rank S L))))
(defun get-rank (S L)
  (if (null S) nil
    (cons
     (cons (car S) (count-references (car S) L nil))
     (get-rank (cdr S) L))))

;; What does this function do?
;; given x, and a list of pairs L,
;; this counts how many references there are to x in L
;;
;; How does the function work?
;; sources keeps track of the sources which have linked to x
;; that way, we can make sure that we don't add duplicates
;;
;; when we're done iterating through the list L, we return the length of sources
;; else, if x is equal to the second element in the current pair (cadar L), we add
;; the first element (caar L) to the list of sources
;; but first, we need to make sure that it is not already in the list of sources
;; and also that it is not a link to itself
;;
;; if those conditions are not satisfied, then we search through the rest of L,
;; until it is exhausted
(defun count-references (x L sources)
  (cond
   ((null L) (len sources))
   ((and
     (equal x (cadar L))
     (not (xmember (caar L) sources))
     (not (eq x (caar L))))
    (count-references x (cdr L) (cons (caar L) sources)))
   (t (count-references x (cdr L) sources))))

;; should be self explanatory, but in case it's not:
;; this gives the length of a list by going over each element in it and adding one
;; when the list is empty, we return 0 and add the rest of the ones together
(defun len (L)
  (if (null L) 0
      (+ 1 (len (cdr L)))))


;; TEST CASE HELPER FUNCTION
;; this is commented out because format is not in the list of allowed functions
;; but I used it to run my test cases defined above
;; (defun test-case (ID Test Result)
;;   (if (equal Test Result)
;;       (format t "Test ~S OK~%" ID)
;;       (format t "FAIL: Test ~S expected ~S got ~S~%" ID Result Test)))

;; submit these

;; do later
(defun xcomplement (S1 S2)
  (cond
    ((null S1) nil)
    ((xmember (car S1) S2) (xcomplement (cdr S1) S2))
    (t (cons (car S1) (xcomplement (cdr S1) S2)))))
;; from assignment 1
(defun xmember (X Y)
  (cond
    ((not Y) nil)
    ((equal X (car Y)) t)
    (t (xmember X (cdr Y)))))

(defun subset0 (S1 S2)
  (let ((c (xcomplement S1 S2)))
    (if (null c) T nil)))


;; can be nested
;; from assignment 1
(defun flatten (X)
  (cond
    ((null X) nil)
    ((atom (car X)) (cons (car X) (flatten (cdr X))))
    (t (append (flatten (car X)) (flatten (cdr X))))))

(defun min0 (L)
  (let ((flat (flatten L))) (reduce (lambda (x y) (if (< x y) x y)) flat)))
(min0 '(5 (2 7 (4 6))))


;; todo reduce
(defun exam (L)
  (reduce (lambda (x y) (+ x y))
          (mapcar
           (lambda (x) (* (+ 2 (car x)) (cdr x))) L)))
(exam '((2 . 5) (4 . 3) (5 . 8)))


(defun exchange0 (L)
  (mapcar (lambda (x) (cons (cdr x) (car x))) L))
(exchange0 '((a . b) (c . d) (e . f)))

;; rethink this one
(defun swapAll (L)
  (if (and (atom (car L)) (atom (cdr L)))
      (cons (cdr L) (car L))
      (mapcar (lambda (x)
                (cond
                  ((and (atom (car x)) (atom (cdr x))) (cons (cdr x) (car x)))
                  ((and (atom (car x)) (not (atom (cdr x)))) (cons (swapAll (cdr x)) (car x)))
                  ((and (not (atom (car x))) (atom (cdr x))) (cons (cdr x) (swapAll (car x))))
                  (t (cons (swapAll (cdr x))(swapAll (car x)))))) L)))

(swapAll '(((a . b) . (c . d)) (e . f)))
(swapAll '(((a . b) . c) (e . f)))


(defun is-simple-pair (x)
  (and (atom (car x)) (atom (cdr x))))

(defun swapAll (L)
  (cond
    ((is-simple-pair L) (cons (cdr L) (car L)))
    (t (cons (if (atom (cdr L))
                 (cdr L)
                 (swapAll (cdr L)))
             (if (atom (car L))
                 (car L)
                 (swapAll (car L)))))))

(defun swap (L)
  (cond
    ((atom L) L)
    (t (cons (if (atom (cdr L)) (cdr L) (swap (cdr L))) (if (atom (car L)) (car L) (swap (car L)))))))
(swap '(((a . b) . (c . d)) (e . f)))
(swap '(((a . b) . c) (e . f)))
#+end_src

* Post midterm stuff
** Prolog
*** Code examples
#+begin_src prolog
% append(L1,L2,L3): append L1 and L2 to get L3
append([],L,L).
append([A|L],L1,[A|L2]) :- append(L,L1,L2).

% member(A,L): A is in list L
member(A,[A|_]).
member(A,[B|L]) :- A \== B, member(A,L).

cartesian([], _, []).
cartesian([A|N], L, M) :-
     pair(A,L,M1),
     cartesian(N, L, M2),
     append(M1, M2, M).
cartesian([a,b], [d,e], [[a,d], [a,e], [b,d], [b,e]]).

pair(_, [], []).
pair(A, [B|L], [[A,B]|N] ) :- pair(A, L, N).

% reverse(X,Y): Y is the reverse of input list X
reverse([], []).
reverse([A|L1], L2) :- reverse(L1, N), append(N, [A], L2).

% sum(L,N) will have N bound to the sum of the numbers in L.
sum([],0).
sum(N,N) :- number(N), !.
sum([A|L],S) :- sum(A,S1), sum(L,S2), S is S1 + S2.

% flatten(L,L1): flatten a list of atoms (atoms and numbers) L to a flat list L1.
flatten([],[]).
flatten([A|L],[A|L1]) :-
     xatom(A), !, flatten(L,L1).
flatten([A|L],R) :-
     flatten(A,A1), flatten(L,L1), append(A1,L1,R).

xatom(A) :- atom(A).
xatom(A) :- number(A).
% cut
x :- p, !, q.
x :-r.
% same as if p then q else r

/*
The four square problem:
Given a natural number N, Sol is bound to a list of 4 or fewer numbers
so that the sum of their squares equals N
,*/

f_sq(N,Sol) :-
   length(L,4),
   L ins 0..N,
   constraint0(N,L),
   label(L),
   removeZero(L,Sol).

constraint0(N,[S1,S2,S3,S4]) :-
   N #= S1*S1 + S2*S2 + S3*S3 + S4*S4,
   S1 #=< S2, S2 #=< S3, S3 #=< S4.
     % this removes some redundant solutions

removeZero([],[]).
removeZero([0|L],L1) :-
   !,
   removeZero(L,L1).
removeZero([A|L],[A|L1]) :-
   removeZero(L,L1).

% find all solutions.
fsq_all(N,L) :- findall(Sol,f_sq(N,Sol),L).

%Given a list L of elements, each of which represents a course and its enrollment, e.g.[cmput325, [john, lily, ken,...]], define a predicate
%courses_taken(+L,+Name,-Courses)

courses_taken([], _, []).
courses_taken([[Course, List] | L], Name, [Course, | Rest]) :-
    member(Name, List),
    !,
    courses_taken(L, Name, Rest).
courses_taken([_ | L], Name, R) :-
    courses_taken(L, Name, R).
#+end_src

#+begin_src sh :exports none :results none
cd code_examples
curl -Lo knight_tour.pl https://raw.githubusercontent.com/triska/clpfd/master/knight_tour.pl
curl -Lo magic_hexagon.pl https://raw.githubusercontent.com/triska/clpfd/master/magic_hexagon.pl
curl -Lo magic_square.pl https://raw.githubusercontent.com/triska/clpfd/master/magic_square.pl
curl -Lo n_factorial.pl https://raw.githubusercontent.com/triska/clpfd/master/n_factorial.pl
curl -Lo n_queens.pl https://raw.githubusercontent.com/triska/clpfd/master/n_queens.pl
curl -Lo sendmory.pl https://raw.githubusercontent.com/triska/clpfd/master/sendmory.pl
curl -Lo sudoku.pl https://raw.githubusercontent.com/triska/clpfd/master/sudoku.pl
curl -Lo tasks.pl https://raw.githubusercontent.com/triska/clpfd/master/tasks.pl
#+end_src


#+include: "code_examples/knight_tour.pl" src prolog
#+include: "code_examples/magic_hexagon.pl" src prolog
#+include: "code_examples/magic_square.pl" src prolog
#+include: "code_examples/n_factorial.pl" src prolog
#+include: "code_examples/n_queens.pl" src prolog
#+include: "code_examples/sendmory.pl" src prolog
#+include: "code_examples/sudoku.pl" src prolog
#+include: "code_examples/tasks.pl" src prolog
*** True/False
- (true ) prolog's backtracking is useful for a CLP solver
- (false) CLP is more general than logic programming
- (false) all variable sin a constraint problem have the same domain
- (true ) a variable domain in CLPFD must be a range of consecutive integers
- (true ) a constraint problem can be solved with C or Java
- (true ) current CLP systems are useful for industrial applications
- (false) a problem with 2 contradictory constraints can still have a solution
- (false) CLP is designed to replace all previous forms of logic programming
- (true ) CLP can be 1 million times more efficient than prolog backtracking
- (false) CLPFD contains one fixed strategy for assigning values to variables
   
** Foundations of logic programming
- Herbrand universe :: The set of all ground terms
*** True/false
Let P be a program consisting of Horn clauses,
let H be its Herbrand universe, and
let B be the Herbrand base of P.
Let the minus sign ‘-’ stand for logical negation
- (false) A Horn clause has at most one negative literal
- (false) p→ (a ∨ b) is a Horn clause
- (true ) (a ∨ b) → p is a Horn clause
- (true ) an atom is a literal
- (true ) a negated atom is a literal
- (true ) any subset of B is an interpretation of P
- (true ) B is a model of P
- (false) the empty set is always a model of P
- (true ) -∀x p(x)  is logically equivalent to ∃x -p(x)
  
  
** Constraint logic programming
** Constraint satisfaction problem
- 3 ingredients
  1. Variables
  2. domains
  3. constraints
- constraint store :: a collection of the primitive constraints, decomposed from user specified constraints.
  it is checked at runtime for consistency whenever the state of these constraints is changed
  (like when a variable is assigned a value)

** Answer set Programming

*** Ground vs not ground
- grounding :: the process of translating a non-groud program to a ground one
- if you have variables, it's ground
- if it's the same function, but with concrete numbers/atoms in place of a variable, it's grounded

*** Problems
**** Elevator problem
- elevator transports passengers from initial floors to goal floors
- when it stops at a floor, any passenger can board or unboard
- the goal is to transport all passengers to their destination floors
**** Gripper problem
- transport all the balls from one room to another
- robot is allowed to move form one room to the other and use its 2 grippers to pick up and put down balls
**** Blocks world
- build one or more vertical stacks of blocks
- only one block moved at a time
- block can be placed on the table or on top of another block
- blocks that are under other blocks cannot be moved
**** N queens problem
n_queens problem
#+begin_src asp
#show q/2.
d(1..queens).
1 {q(X,Y):d(Y)} 1 :-d(X).
:- d(X), d(Y), d(X1), q(X,Y), q(X1,Y), X1 != X.
:- d(X), d(Y), d(Y1), q(X,Y), q(X,Y1), Y1 != Y.
% the above is not needed logically
:- d(X), d(Y), d(X1), d(Y1), q(X,Y), q(X1,Y1),
X != X1, Y != Y1, abs(X -X1) == abs(Y -Y1).
:-d(Y), not hasq(Y).
hasq(Y) :-d(X), d(Y), q(X,Y).
#+end_src
*** Ferry problem
#+begin_src asp
move(ferry, From, To, Time)
board(Car, Location, Time)
unboard(Car, Location, Time)
at(Object, Location, Time) % object is at Location at Time
in(ferry, Car, T) % Car is in ferry at Time
empty(ferry, T) % ferry is empty at Time
moving(ferry, T) % don't care about location at Time
affected(Object, T) % Object is affected by some action at Time

% constrains

% ferry cannot be moved to 2 different locations at the same time
:- at(ferry, Loc, T), at(ferry, Loc1, T), Loc != Loc1.

% two cars cannot be boarded at the same time and location
:- board(Car1, Loc, T), board(Car2, Loc, T), Car1 != Car2.
#+end_src
