#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
* Pre midterm stuff

** SECD virtual machine
- https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830027
- https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830028


#+begin_example lisp
(lambda (x y) (if (eq x y) x (+ 1 y)))
(LDF
  ( LD (1.2) LD (1.1) EQ SEL (LD (1.1)) (LD (1.2) LDC 1 ADD)
  RTN ))
(LDF (LD (1.2) LD (1.1) EQ SEL (LD (1.1) JOIN) (LD (1.1) ((LD 1.2) LDC 1 + JOIN))
             RTN) )
#+end_example

#+begin_example lisp
(lambda (x y) ((lambda (z) (+ x y z)) 6))
Note that the body of the outside lambda function is an application ((lambda (z) (+ x y z)) 6)),
where the operator + is generic, just like the same operator in lisp.
To decompose the over-all task, you should first show the SECD code for this expression and denote it by, e.g.,e’.
Then, plug it into the full solution.
Answer: e’ = (NIL LDC 6 CONS LDF (LD (2.1) LD (1.2) LD (1.1) ADD RTN) AP)
Then, the full solution is:(LDF e’ || (RTN))
#+end_example

#+begin_example lisp
(lambda (x) ((lambda (z) (+ x x z)) 4))
Note that the body of the outside lambda function is an application((lambda (z) (+ x x z)) 4)).
To decompose the overall task, you should first show the SECD code for this expression anddenote it by, e.g.,e’.
Then, plug it into the full solution.
Answer:(LDF)  (e’ || (RTN)), where e’is
e = (NIL LDC 4 CONS (LDF (LD (2.1) LD (1.1) LD (1.1) ADD RTN) ) AP
#+end_example
** Context based interpreter
#+begin_example lisp
((lambda (f) (f 2 3)) (lambda (x y) (* x (+ y 1))))

context when (f 2 3) is evaluated (initial context is CT0)
{f -> [(lambda (x y) (* x (+ y 1))), CT0]} U CT0

context when (* x (+ y 1)) is evaluated
{x -> 2, y -> 3} U CT0
#+end_example

#+begin_example lisp
eval
    ((lambda (f x) (cons z (f x x))) (lambda (u v) (cons u v)) 5)
in CT0

CT0 = {z -> 2}

context when (cons z (f x x)) is evaluated
A: Let e1 denote(lambda (u v) (cons u v)).
Then, eval(cons z (f x x))in the context{f→[e1, CT0], x→5}∪CT0
where[e1, CT0] denotes the corresponding closure. Denote this context by CT1.

context when(f x x) is evaluated
A: Continuing the above, eval(f x x)in CT1.
Also, eval z in CT1 (not part of thequestion), which yields 2.

context when(cons u v) is evaluated
A: Continuing the above, eval f in CT1 gives [e1, CT0]
and eval(x x)in CT1 gives(5 5)
Now, apply the function ine1and we have eval(cons u v)in the context{u→5, v→5}∪CT0
===
Overall result is
Two applications of cons gives us (2 . (5 . 5)), or you can simplify it to (2 5 . 5).
#+end_example


** Lambda calculus
#+begin_example
truth table practice
Lxy|xNM
if x is true then N else M

x y | output
T T | F
T F | F
F T | F
F F | F
(Lxy|F)

x y | output
T T | F
T F | F
F T | F
F F | T
(Lxy|xF(NOT y)

x y | output
T T | F
T F | F
F T | T
F F | F
(Lxy|xFy)


x y | output
T T | F
T F | F
F T | T
F F | T
(Lxy|xFT)

x y | output
T T | F
T F | T
F T | F
F F | F
(Lxy|yFx)

x y | output
T T | F
T F | T
F T | F
F F | T
(Lxy|yFT)

x y | output
T T | F
T F | T
F T | T
F F | F
(Lxy|x(NOT y)y)

x y | output
T T | F
T F | T
F T | T
F F | T
(Lxy|y(NOT x)T)
(*Lxy|x(NOT y)T)

x y | output
T T | T
T F | F
F T | F
F F | F
(Lxy|xyF)

x y | output
T T | T
T F | F
F T | F
F F | T
(Lxy|xy(NOT y)

x y | output
T T | T
T F | F
F T | T
F F | F
(Lxy|y)

x y | output
T T | T
T F | F
F T | T
F F | T
(Lxy|xyT)

x y | output
T T | T
T F | T
F T | F
F F | F
(Lxy|x)

x y | output
T T | T
T F | T
F T | F
F F | T
(Lxy|xT(NOT y))

x y | output
T T | T
T F | T
F T | T
F F | F
(Lxy|xTy)

x y | output
T T | T
T F | T
F T | T
F F | T
(Lxy|T)
#+end_example

** Lisp
*** Useful functions
#+begin_src lisp
;; useful functions


(defun xmember (X Y)
  (cond
   ((not Y) nil)
   ((equal X (car Y)) t)
   (t (xmember X (cdr Y)))))

(defun xcomplement (S1 S2)
  (cond
    ((null S1) nil)
    ((xmember (car S1) S2) (xcomplement (cdr S1) S2))
    (t (cons (car S1) (xcomplement (cdr S1) S2)))))
(assert (equal (xcomplement '(a b c d e) '(a c)) '(b d e)))

(defun xfilter (test L)
  (cond
    ((null L) nil)
    ((funcall test (car L)) (cons (car L) (xfilter test (cdr L))))
    (t (xfilter test (cdr L)))))

(defun xrotate (L)
  (if (null L) nil
      (append (cdr L) (list (car L)))))
(assert (equal (xrotate '(1 2 3 4)) '(2 3 4 1)))

(cdr '(1 2))
(defun xrotateAll (L)
  (if (atom L) L
      (xrotate (mapcar 'xrotateAll L))))
(assert (equal (xrotateAll '(a b (1 2 3 4) (c d))) '(b (2 3 4 1) (d c) a)))
(assert (equal (xrotateAll '((a b) () (1 2 3 4) c d)) '(nil (2 3 4 1) c d (b a))))
(assert (equal (xrotateAll '(a b nil (1 2 (3 4)))) '(b nil (2 (4 3) 1) a)))

;; it flattens lists with sublists of any depth such that the result is just a list of atoms
;; assumes that NIL will not appear in the list given
;; Test cases (the test-case function is in a comment at the end of this file)
;; (test-case 2.1 (flatten '(a (b c) d)) '(a b c d))
;; (test-case 2.2 (flatten '((((a))))) '(a))
;; (test-case 2.3 (flatten '(a (b c) (d ((e)) f))) '(a b c d e f))
(defun flatten (X)
  (cond
    ((null X) nil)
    ((atom (car X)) (cons (car X) (flatten (cdr X))))
    (t (append (flatten (car X)) (flatten (cdr X))))))

;; it removes duplicate items from a list, preserving the order of elements
;; assumes that NIL will not appear in the list given
;; (test-case 3.1 (remove-duplicate '(a b c a d b)) '(c a d b)) ;abcd is also a valid order
(defun remove-duplicate (X)
  (cond
   ((not X) nil)
   ((xmember (car X) (cdr X)) (remove-duplicates (cdr X)))
   (t (cons (car X) (remove-duplicates (cdr X))))))

;; it mixes the elements of L1 and L2, interweaving them
;; if one list is shorter than the other, append remaining elements to the end
(defun mix (L1 L2)
  (cond
   ((not L2) L1)
   ((not L1) L2)
   (t (cons (car L1) (mix L2 (cdr L1))))))

;; it returns all the subsets of a given set
(defun allsubsets (L)
  (if (null L) (list nil)
    (gen-subsets (car L) (allsubsets (cdr L)))))

;; What does this function do?
;; it generates subsets for a given list
;;
;; How does the function work?
;; I got the algorithm from wikipedia:  https://en.wikipedia.org/wiki/Power_set#Recursive_definition
;; For a non-empty set S (assignment calls it L)
;; let e be any element of the set (car L), which we get from allsubsets above
;; and T is the relative complement of e
;; then the power set of S is a union of a power set of T and
;; a power set of T whose each element is expanded with e
(defun gen-subsets (e Tcomplement)
  (if (not Tcomplement) nil
    (cons
     (cons e (car Tcomplement))
     (cons (car Tcomplement) (gen-subsets e (cdr Tcomplement))))))


;; QUESTION 6
;; Part 1
;;
;; What does this function do?
;; given a list L, which is a list of pairs representing linkage
;; and x, the page to start at
;; it returns a list of all webpages that are reachable if you start at x, and follow links to other pages
;;
;; How does the function work?
;; it finds all the websites that can be reached, then removes duplicate items
;; and also x, if it is present (see remove-x)
;; see find-links
;;
;; Test cases (the test-case function is in a comment at the end of this file)
;; (test-case 6.11 (reached 'google '( (google shopify) (google aircanada) (amazon aircanada))) '(SHOPIFY AIRCANADA))
;; (test-case 6.12 (reached 'google '( (google shopify) (shopify amazon) (amazon google) ) ) '(amazon shopify))
;; (test-case 6.13 (reached 'google '( (google shopify) (shopify amazon) (amazon indigo)  )) '(INDIGO amazon shopify))
;; (test-case 6.14 (reached 'google '( (google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google) ))  '(SHOPIFY delta AIRCANADA))
;; (test-case 6.14 (reached 'google '( (google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google) ))  '(SHOPIFY delta AIRCANADA))
;; ;;backwards reached
;; (test-case 6.15 (reached 'google '((shopify aircanada) (google shopify))) '(aircanada shopify))
;; ;; cycle
;; (test-case 6.16 (reached 'a '((a b) (b a) (a c))) '(b c))
(defun reached (x L)
  (remove-duplicate
   (remove-x x
             (find-links x L L nil))))

;; What does this function do?
;; given x, and a list L, it will remove occurrences of x in L
;;
;; How does the function work?
;; it checks each item in the list, and if x is equal to that item, we ignore it
;; and recurse on (cdr l)
;; otherwise, we include the item, and remove duplicates from the rest of the list
(defun remove-x (x L)
  (cond
   ((null L) nil)
   ((eq x (car L)) (remove-x x (cdr L)))
   (t (cons (car L) (remove-x x (cdr L))))))

;; What does this function do?
;; it finds all of the places that can be reached
;; (see the description for reached)
;; the difference here, is that there can be duplicates,
;; and the starting point x, can also be included in the result
;; in reached, these are removed from the result returned by this function
;;
;; How does the function work?
;; x is the starting point to search
;; L is the given list of links
;; original is the original list of links. It starts out being the same as L,
;;  but because we need to check each pair, we use L to go over each element in the list
;;  and when we need the original list, we pass that in.
;; visited is a list to keep track of websites we have visited
;; if we've already visited the site, then we return nil
;; if we've exhausted all elements, we return x in a list,
;; if there are still items in L, we recursively build that list
;; so the end result contains all of the websites visited
;;
;; (caar L) is the first website in the first element of the list given
;;  e.g. (caar '((a b) (c d))) should give a
;; (cadar L) is the second website in the first element of the list given
;;  e.g. (caar '((a b) (c d))) should give b
;;
;; when recursively building this list, we check if x is equal to (caar L)
;; which means that the website x links to somewhere else
;; we get that using (cadar L) and then recursively find out which
;; websites (cadar L) links to since those can also be reached from x
;;
;; we also search the rest of the list, since x could link to other places later
;; in the list
(defun find-links (x L original visited)
  (cond
   ((null L) (list x)) ; done iteration, ran out of items
   ((xmember x visited) nil)
   ((eq x (caar L)) (append (find-links (cadar L) original original (cons x visited))
                            (find-links x (cdr L) original visited)))
   (t (find-links x (cdr L) original visited))))

;; QUESTION 6
;; Part 2
;;
;; What does this function do?
;; given S, which is a list of websites
;; L, which is a list of pairs representing linkage between websites,
;; this returns a permutation of S, such that the websites
;; with the most links to it is first in the list
;; if 2 pages are equally important, the order does not matter
;; a site referring to itself does not count
;; and a multiple references to a site from another same site only counts once
;;
;; How does the function work?
;; first, we count the references to each site using get-rank (see below)
;; then, we sort it using mySort, which sorts based on the number of references counted
;; finally, we get rid of the counts, and return just the final sorted list of
;; elements that were originally in S
;;
;; Test cases (the test-case function is in a comment at the end of this file)
;; (test-case 6.221 (rank '(google shopify aircanada amazon) '((google shopify) (google aircanada) (amazon aircanada))) '(AIRCANADA SHOPIFY GOOGLE AMAZON))
;; (test-case 6.222 (rank '(google shopify amazon) '((google shopify) (shopify amazon) (amazon google))) '(GOOGLE SHOPIFY AMAZON))
;; (test-case 6.223 (rank '(google shopify amazon indigo) '((google shopify) (shopify amazon) (amazon indigo))) '(SHOPIFY AMAZON INDIGO GOOGLE))
;; (test-case 6.224 (rank '(google shopify aircanada amazon delta) '((google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google))) '(AIRCANADA SHOPIFY DELTA GOOGLE AMAZON))
(defun rank (S L)
  (map-get-cars
   (mySort
    (get-rank S L))))

;; I can't use mapcar for this assignment, so this just
;; goes over each element, and maps each pair to just the first element
;; example: ((1 2) (3 4) (5 6)) becomes (1 3 5)
(defun map-get-cars (L)
  (if (null L) nil
    (cons (caar L) (map-get-cars (cdr L)))))

;; Custom sort function, this function was given to us on eclass
(defun mySort (L)
  (sort L 'greaterThan))

;; Custom sort function, this function was given to us on eclass
;; it sorts such that the item with the greatest second item in the pair comes first
;; I use cdr instead of cadr here because I end up with a list of dotted pairs, so
;; cdr gets me an atom, which is the second item in the pair
(defun greaterThan (L1 L2)
  (> (cdr L1) (cdr L2)))

;; What does this function do?
;; given S, which is a list of websites
;; L, which is a list of pairs representing linkage between websites,
;; this returns a list of pairs, where the first item in the pair comes from list S,
;; and the second item is how many unique links there are to that website
;;
;; How does the function work?
;; for each element in S, we count how many references there are to that element (see count-references)
;; we then take that element and map it to a pair with the first element being itself, and the second
;; element being the result of count-references
;;
;; Test cases (the test-case function is in a comment at the end of this file)
;; (test-case 6.21 (test-rank '(google shopify aircanada amazon) '((google shopify) (google aircanada) (amazon aircanada))) '((AIRCANADA 2) (SHOPIFY 1) (GOOGLE 0) (AMAZON 0)))
;; (test-case 6.22 (test-rank '(google shopify amazon) '((google shopify) (shopify amazon) (amazon google))) '((GOOGLE 1) (SHOPIFY 1) (AMAZON 1)))
;; (test-case 6.23 (test-rank '(google shopify amazon indigo) '((google shopify) (shopify amazon) (amazon indigo))) '((SHOPIFY 1) (AMAZON 1) (INDIGO 1) (GOOGLE 0)))
;; (test-case 6.24 (test-rank '(google shopify aircanada amazon delta) '((google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google))) '((AIRCANADA 2) (SHOPIFY 1) (DELTA 1) (GOOGLE 0) (AMAZON 0)))
;; ;; multiple references don't count and references to self don't count
;; (test-case 6.25 (test-rank '(google shopify aircanada amazon delta) '((google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (aircanada aircanada) (aircanada delta) (google google))) '((AIRCANADA 2) (SHOPIFY 1) (DELTA 1) (GOOGLE 0) (AMAZON 0)))
;;
;; this just makes sure that my test cases match the result that i'm expecting it to be equal to
;; since get-rank returns a list of dotted pairs instead of a list of pairs
;; (defun test-rank (S L)
;;   (mapcar (lambda (x) (list (car x) (cdr x)))
;;           (mySort (get-rank S L))))
(defun get-rank (S L)
  (if (null S) nil
    (cons
     (cons (car S) (count-references (car S) L nil))
     (get-rank (cdr S) L))))

;; What does this function do?
;; given x, and a list of pairs L,
;; this counts how many references there are to x in L
;;
;; How does the function work?
;; sources keeps track of the sources which have linked to x
;; that way, we can make sure that we don't add duplicates
;;
;; when we're done iterating through the list L, we return the length of sources
;; else, if x is equal to the second element in the current pair (cadar L), we add
;; the first element (caar L) to the list of sources
;; but first, we need to make sure that it is not already in the list of sources
;; and also that it is not a link to itself
;;
;; if those conditions are not satisfied, then we search through the rest of L,
;; until it is exhausted
(defun count-references (x L sources)
  (cond
   ((null L) (len sources))
   ((and
     (equal x (cadar L))
     (not (xmember (caar L) sources))
     (not (eq x (caar L))))
    (count-references x (cdr L) (cons (caar L) sources)))
   (t (count-references x (cdr L) sources))))

;; should be self explanatory, but in case it's not:
;; this gives the length of a list by going over each element in it and adding one
;; when the list is empty, we return 0 and add the rest of the ones together
(defun len (L)
  (if (null L) 0
      (+ 1 (len (cdr L)))))


;; TEST CASE HELPER FUNCTION
;; this is commented out because format is not in the list of allowed functions
;; but I used it to run my test cases defined above
;; (defun test-case (ID Test Result)
;;   (if (equal Test Result)
;;       (format t "Test ~S OK~%" ID)
;;       (format t "FAIL: Test ~S expected ~S got ~S~%" ID Result Test)))

;; submit these

;; do later
(defun xcomplement (S1 S2)
  (cond
    ((null S1) nil)
    ((xmember (car S1) S2) (xcomplement (cdr S1) S2))
    (t (cons (car S1) (xcomplement (cdr S1) S2)))))
;; from assignment 1
(defun xmember (X Y)
  (cond
    ((not Y) nil)
    ((equal X (car Y)) t)
    (t (xmember X (cdr Y)))))

(defun subset0 (S1 S2)
  (let ((c (xcomplement S1 S2)))
    (if (null c) T nil)))


;; can be nested
;; from assignment 1
(defun flatten (X)
  (cond
    ((null X) nil)
    ((atom (car X)) (cons (car X) (flatten (cdr X))))
    (t (append (flatten (car X)) (flatten (cdr X))))))

(defun min0 (L)
  (let ((flat (flatten L))) (reduce (lambda (x y) (if (< x y) x y)) flat)))
(min0 '(5 (2 7 (4 6))))


;; todo reduce
(defun exam (L)
  (reduce (lambda (x y) (+ x y))
          (mapcar
           (lambda (x) (* (+ 2 (car x)) (cdr x))) L)))
(exam '((2 . 5) (4 . 3) (5 . 8)))


(defun exchange0 (L)
  (mapcar (lambda (x) (cons (cdr x) (car x))) L))
(exchange0 '((a . b) (c . d) (e . f)))

;; rethink this one
(defun swapAll (L)
  (if (and (atom (car L)) (atom (cdr L)))
      (cons (cdr L) (car L))
      (mapcar (lambda (x)
                (cond
                  ((and (atom (car x)) (atom (cdr x))) (cons (cdr x) (car x)))
                  ((and (atom (car x)) (not (atom (cdr x)))) (cons (swapAll (cdr x)) (car x)))
                  ((and (not (atom (car x))) (atom (cdr x))) (cons (cdr x) (swapAll (car x))))
                  (t (cons (swapAll (cdr x))(swapAll (car x)))))) L)))

(swapAll '(((a . b) . (c . d)) (e . f)))
(swapAll '(((a . b) . c) (e . f)))


(defun is-simple-pair (x)
  (and (atom (car x)) (atom (cdr x))))

(defun swapAll (L)
  (cond
    ((is-simple-pair L) (cons (cdr L) (car L)))
    (t (cons (if (atom (cdr L))
                 (cdr L)
                 (swapAll (cdr L)))
             (if (atom (car L))
                 (car L)
                 (swapAll (car L)))))))

(defun swap (L)
  (cond
    ((atom L) L)
    (t (cons (if (atom (cdr L)) (cdr L) (swap (cdr L))) (if (atom (car L)) (car L) (swap (car L)))))))
(swap '(((a . b) . (c . d)) (e . f)))
(swap '(((a . b) . c) (e . f)))
#+end_src

* Post midterm stuff
** Prolog
*** Code examples
#+begin_src prolog
% append(L1,L2,L3): append L1 and L2 to get L3
append([],L,L).
append([A|L],L1,[A|L2]) :- append(L,L1,L2).

% member(A,L): A is in list L
member(A,[A|_]).
member(A,[B|L]) :- A \== B, member(A,L).

cartesian([], _, []).
cartesian([A|N], L, M) :-
     pair(A,L,M1),
     cartesian(N, L, M2),
     append(M1, M2, M).
cartesian([a,b], [d,e], [[a,d], [a,e], [b,d], [b,e]]).

pair(_, [], []).
pair(A, [B|L], [[A,B]|N] ) :- pair(A, L, N).

% reverse(X,Y): Y is the reverse of input list X
reverse([], []).
reverse([A|L1], L2) :- reverse(L1, N), append(N, [A], L2).

% sum(L,N) will have N bound to the sum of the numbers in L.
sum([],0).
sum(N,N) :- number(N), !.
sum([A|L],S) :- sum(A,S1), sum(L,S2), S is S1 + S2.

% flatten(L,L1): flatten a list of atoms (atoms and numbers) L to a flat list L1.
flatten([],[]).
flatten([A|L],[A|L1]) :-
     xatom(A), !, flatten(L,L1).
flatten([A|L],R) :-
     flatten(A,A1), flatten(L,L1), append(A1,L1,R).

xatom(A) :- atom(A).
xatom(A) :- number(A).
% cut
x :- p, !, q.
x :-r.
% same as if p then q else r

% setIntersect(+S1,+S2,-S3)
% this takes in 2 lists of atoms, S1 and S2.
% S3 is a list of atoms that are in both S1 and S2
% S1 is always a list of distinct atoms.
setIntersect([], _, []). % if first list is empty return empty list
setIntersect([First | Rest], S2, [First | Output]) :-
  xmember(First, S2), setIntersect(Rest, S2, Output). % if First element of S1 is in S2 then add it to the output list, and check the rest of S1 against S2
setIntersect([_ | R], S2, A) :-
  setIntersect(R, S2, A).
/*
 swap(+L, -R)
 this takes in a list L, and makes it so that R
 has every 2 elements swapped with each other
,*/
%:- begin_tests(question2).
%test(swap1) :-
%  swap([a,1,b,2], W),
%  W = [1,a,2,b].
%test(swap2) :-
%  swap([a,1,b], W),
%  W = [1,a,b].
%:- end_tests(question2).
swap([], []).
swap([A], [A]).
swap([A, B | R1], [B, A | R2]) :-
  swap(R1, R2). 

/*
 filter(+L,+OP,+N,-L1)
 this takes in L, a possibly nested list of numbers, and outputs L1,
 which has all of the numbers in L that meet certain criteria.
 The criteria is defined by OP and N, where OP is "greaterThan", "equal",
 or "lessThan", and N is a number.
,*/
%:- begin_tests(question3).
%test(filtergreater) :-
%  filter([3,4,[5,2],[1,7,3]],greaterThan,3,W),
%  W = [4,5,7].
%test(filterequal) :-
%  filter([3,4,[5,2],[1,7,3]],equal,3,W),
%  W = [3,3].
%test(filterless) :-
%  filter([3,4,[5,2],[1,7,3]],lessThan,3,W),
%  W = [2,1].
%:- end_tests(question3).

filter([], _, _, []).
filter([F | R], OP, N, [F | Output]) :-
  number(F),
  doOP(F, OP, N),
  filter(R, OP, N, Output).

filter([F | R], OP, N, Output) :-
  \+ number(F),
  filter(F, OP, N, Out1),
  filter(R, OP, N, Out2),
  append(Out1, Out2, Output).

filter([_ | R], OP, N, Output) :-
  filter(R, OP, N, Output).

doOP(X, greaterThan, Y) :- X > Y.
doOP(X, lessThan, Y) :- X < Y.
doOP(X, equal, Y) :- X =:= Y.
/*
 countAll(+L,-N)
 given L, a flat list of atoms, the number of occurences of each atom is counted
 N is a list of pairs of the form [a,n], where a is the atom and n is the
 number of occurences. N is sorted in increasing order by n. If n is tied,
 there is no tie breaking functionality based on what a is.
,*/
%:- begin_tests(question4).
%test(countall) :-
%  countAll([a,b,e,c,c,b],N),(
%  N = [[a,1],[e,1],[b,2],[c,2]];
%  N = [[e,1],[a,1],[b,2],[c,2]]
%).% other permutations are possible, mine seems to return the second permutation
%:- end_tests(question4).

countAll([], []).
countAll([F | R], SortedOutput) :-
  countAll(R, IntermediateOutput),
  incrementCount(F, IntermediateOutput, Output),
  bubble_sort(Output, SortedOutput).

incrementCount(X, [], [[X,1]]).
incrementCount(X, [[X, CountX] | R], [[X, CountXPlusOne] | R]) :-
  CountXPlusOne is CountX + 1.
incrementCount(Y, [[X, CountX] | R], [[X, CountX] | T]) :-
  X \= Y,
  incrementCount(Y, R, T).

bubble_sort(L, L) :- is_sorted(L).
bubble_sort(L, Output) :-
  xappend(X, [[A, Acount],[B, Bcount] | Y], L),
  Acount > Bcount,
  xappend(X, [[B, Bcount], [A, Acount] | Y], R),
  bubble_sort(R, Output).

is_sorted([]).
is_sorted([[_,_]]).
is_sorted([[_, Acount], [B,Bcount] | R]) :-
  Acount =< Bcount,
  is_sorted([[B, Bcount] | R]).

/*
 sub(+L,+S,-L1)
 this takes in a possibly nested list of atoms L, and a list of pairs S
 of the form [[x1, e1], ...].
 L1 is the same as L, except that any occurences of xi is replaced by ei.
 xi is always an atom
 ei is an arbitrary expression

 every xi is assumed to be distinct, and xi will never occur in ei
,*/
%:- begin_tests(question5).
%test(sub) :-
%  sub([a,[a,d],[e,a]],[[a,2]],L),
%  L= [2,[2,d],[e,2]].
%
%test(sub2) :-
%  sub([a,b,c], [[a,d], [b, c]], [d, c, c]).
%
%test(sub3) :-
%  sub([a,[b, [c, [d]]]], [[a,z], [z, v], [c, g], [d, p]] , [z,[b, [g, [p]]]]).
%
%test(subexpression) :-
%  sub([a, b, c], [[b, 4 < 1]], [a, 4<1, c]).
%:- end_tests(question5).

sub([], _, []).
sub([X | R], S, [Y | Output]) :- % is an atom
  atom(X),
  find_substitution(X, S, Y),
  sub(R, S, Output).
sub([L | R], S, [Output | ROutput]) :- % not an atom
  sub(L, S, Output),
  sub(R, S, ROutput).

find_substitution(X, [], X).
find_substitution(X, [[X, E] | _], E).
find_substitution(X, [[Xi, _] | S], Output) :-
  X \= Xi,
  find_substitution(X, S, Output).

/*
 allConnected(+L)
 this takes in a list, and it returns true if every node in L can reach every
 other node in L

 How it works:
 first, an empty list is all connected (base case)

 then, we check every element in L, and see if it is connected using the
 allConnected helper predicate defned below
,*/
%:- begin_tests(question6).
%test(allconnected) :-
%  allConnected([a,b,c]).
%:- end_tests(question6).

allConnected([]).
allConnected([F | R]) :-
  allConnectedHelper(F, R),
  allConnected(R).

/* allConnectedHelper(-X, -L)
 this checks if node X is connected to all elements in L

 How it works:
 if L is empty, then it is all connected (base case)
 else we check if X is connected to the first element in L,
 and also every other element in L by recursing on the tail of L

 the connected predicate is defined below
 ,*/
allConnectedHelper(_, []).
allConnectedHelper(X, [F | R]) :-
  connected(X, F),
  allConnectedHelper(X, R).

connected(X,Y) :-
  edge(X,Y);
  edge(Y,X).

/* clique(+L)
 The clique problem is a graph-theoretic problem of finding a subset of nodes
 where each is connected to every other node in the subset. 

 This code is given to us in the assignment
,*/
% for the node example defined in eclass
%:- begin_tests(clique).
%test(clique) :-
%  clique([a,b,c]).
%:- end_tests(clique).
clique(L) :- 
  findall(X,node(X),Nodes),
  subset(L,Nodes), allConnected(L).

subset([], _).
subset([X|Xs], Set) :-
  append(_, [X|Set1], Set),
  subset(Xs, Set1).

/*
 convert(+Term,-Result)
 this takes in a Term, which is a list of atoms
 anything between two q atoms are kept as-is,
 while any 'e' outside of two q atoms are dropped,
 and anything else outside of two q atoms are changed to c

 for an unmatched q, anything after is considered outside of a q pair, so
 'e' will be dropped, and anything else changed to c. This happens when there
 is an odd number of q atoms

 How it works:
 we call the convertHelper predicate defined below, which takes in the same
 2 arguments as convert. It also takes in a third argument, which is a boolean
 to help with keeping track of matching q atoms
,*/
%:- begin_tests(question7).
%test(convert1) :-
%  convert([e,e,a,e,b,e],R),
%  R = [c,c].
%test(convert2) :-
%  convert([e,q,a,b,e,e],R),
%  R = [q,c,c].
%test(convert3) :-
%  convert([e,a,e,e],R),
%  R = [c].
%test(convert4) :-
%  convert([e,q,a,e,b,q,e,a,e],R),
%  R = [q,a,e,b,q,c].
%test(convert5) :-
%  convert([a,q,e,l,q,r,e,q,b,e],R),
%  R = [c,q,e,l,q,c,q,c].
%test(convert6) :-
%  convert([q,e,q,b,q,e,l,q,a,e],R),
%  R = [q,e,q,c,q,e,l,q,c].
%:- end_tests(question7).

convert(Term, Result) :-
  convertHelper(Term, Result, false).


/* convertHelper(+Term, -Result, +Qfound)
 this is the main logic for convert.
 this takes in a Term, which is a list of atoms
 anything between two q atoms are kept as-is,
 while any 'e' outside of two q atoms are dropped,
 and anything else outside of two q atoms are changed to c

 for an unmatched q, anything after is considered outside of a q pair, so
 'e' will be dropped, and anything else changed to c. This happens when there
 is an odd number of q atoms
 Read the comments for the convert predicate above to see what this does.

 This has the same input and output arguments as convert. It also takes in a
 third argument, which is a boolean to help with keeping track of matching q
 atoms

 How it works:
 if Term is empty, then so is the result (base case)
 
 next, we check the head of Term. if it is a q, then a quote is starting.
 we check if there is a matching q using the end_q_exists predicate defined below.
 we then recurse on the tail of Term, and also Qfound, the third argument is now
 true. We also add q to the output.

 if a q is found, but no end q exists, everything after it is subject to the
 substitution rules we defined, so we recurse on the rest of Term
 We also add q to the output

 if a q is found, and Qfound is true, then we found the end of a quote
 we recurse on the tail of Term, and also Qfound is now false
 We also add q to the output

 if an e is found, and Qfound is false, then we are not in a quote and should
 drop the e. We recurse on the tail of Term without adding e to the output.

 if we find any character that is not q inside a quote, we leave it untouched
 and recurse on the tail of Term. That atom is added to the output.

 if we find any character that is not q or e outside a quote, we change it to c
 and recurse on the tail of Term. c is added to the output.
,*/
convertHelper([], [], _).
convertHelper([q | R], [q | Output], false) :-
  end_q_exists(R),
  convertHelper(R, Output, true).
convertHelper([q | R], [q | Output], false) :-
  \+ end_q_exists(R),
  convertHelper(R, Output, false).
convertHelper([q | R], [q | Output], true) :-
  convertHelper(R, Output, false).
convertHelper([e | R], Output, false) :-
  convertHelper(R, Output, false).
convertHelper([X | R], [X | Output], true) :-
  X \= q,
  convertHelper(R, Output, true).
convertHelper([X | R], [c | Output], false) :-
  X \= q,
  X \= e,
  convertHelper(R, Output, false).

/* end_q_exists(+L)
 this takes in a list of atoms, and is true if there is a q atom in the list
 it assumes that the first q in the list is already removed
 (otherwise it would always return true!)

 How it works:
 if q is found, true is returned, else, we recurse on the tail of L
 ,*/
end_q_exists([q | _]).
end_q_exists([X | R]) :-
  X \= q,
  end_q_exists(R).

% SEND + MORE = MONEY problem
encrypt(W1,W2,W3) :- 
   length(W1,N),           % if you need to know the lengths of words
   length(W3,N1),   
   append(W1,W2,W),
   append(W,W3,L),
   list_to_set(L,Letters), % remove duplicates, a predicate in list library
   [LeadLetter1|_] = W1,   % identify the leading letter to be set to non-zero
   [LeadLetter2|_] = W2,
   [LeadLetter3|_] = W3,
   !,                      % never need to redo the above
   Letters ins 0..9,
   all_distinct(Letters),
   LeadLetter1 #\= 0,
   LeadLetter2 #\= 0,
   LeadLetter3 #\= 0,
   digits_to_number(W1, Sum1),
   digits_to_number(W2, Sum2),
   digits_to_number(W3, Sum3),
   Sum1 + Sum2 #=  Sum3,
   label(Letters).

% This predicate converts a list of numbers to an
% actual number, assuming base10. We sum up
% each number, and multiply by 10 based on its
% position in the list
%:- begin_tests(digits).
%test(digits) :-
%  digits_to_number([1,2,3,4,5,6,7,8,9,0], 1234567890).
%:-end_tests(digits).
digits_to_number(Digits, Number) :-
  digits_to_number(Digits, 0, Number).
digits_to_number([], Sum, Sum).
digits_to_number([Digit | Rest], Sum, Number) :-
  PartialSum #= Sum*10 + Digit,
  digits_to_number(Rest, PartialSum, Number).

% subsetsum(L, N)
% This predicate takes in a list L, and an integer N,
% and it determines if there exists a subset of the list such that 
% the sum is equal to N
%:-end_tests(subsetsum).
subsetsum(L, N) :-
  same_length(L, Coefficients),
  Coefficients ins 0..1,
  maplist(applyCoeff, L, Coefficients, Output),
  sum(Output, #=, N),
  label(Coefficients).

applyCoeff(Coeff, X, Y) :- Y #= Coeff * X.

% assign(W1, W2)
% given facts about papers and reviewers as defined in the question,
%
% (They are of the form): 
% paper(ID, Co-author1, Co-author2, Subject)
% reviewer(Name, Subject1, Subject2)
%
% this predicate assigns reviewers to the lists W1 and W2,
% such that  no one reviews their own paper,
% and also each reviewer must have the subject in their fact
% No reviewer is assigned more than workLoadAtMost papers,
% and each paper is assigned to 2 reviewers. 
% The paper index corresponds to the indices in W1 and W2.
% For example, The names that appear at index 1 review paper 1.
% 
% How it works:
% Because this is a quite complex problem, we want to restrict the
% domain as much as possible as soon as possible. 
% Each reviewer is assigned a number between 0 and the total number of reviewers
% multiplied by workLoadAtMost times minus one. We do this so that we can use
% modulo arithmetic and the all_distinct predicate. My initial solution
% instead generated two lists of numbers and then made sure that no
% number appeared more than workLoadAtMost times in either, but that
% was way too slow, which is why we're using the modulo solution here.
%
% The domains are generated in the gen_domain predicate defined below
%
% Then, we make sure that once we have 2 lists of numbers,
% that these reviewers satisfy the constraints above using the
% constrain_paper predicate defined below
%
% Finally, we convert the reviewer numbers to the reviewer
% name using modulo arithmetic. We use maplist with
% the reviewer_to_int predicate defined below.
%
% Test cases:
% This smaller example works almost instantly on my machine
%paper(1,lily,xxx,ai).
%paper(2,peter,john,database).
%paper(3,ann,xxx,theory).
%paper(4,ken,lily,network).
%paper(5,kris,xxx,games).
%reviewer(lily,theory,network).
%reviewer(john,ai,theory).
%reviewer(peter,database,network).
%reviewer(ann,theory,network).
%reviewer(kris,theory,games).
%reviewer(ken,database,games).
%reviewer(bill,database,ai).
%reviewer(jim,theory,games).
%workLoadAtMost(2).
%?- assign(W1, W2).
%W1 = [john, ken, lily, peter, ken],
%W2 = [bill, bill, john, ann, jim].
%
% This larger example takes about a minute to run on my
% quad core laptop (i7-7700hq)
%paper(1,lily,xxx,ai).
%paper(2,peter,john,database).
%paper(3,ann,xxx,theory).
%paper(4,ken,lily,network).
%paper(5,kris,xxx,games).
%paper(6,jim,xxx,games).
%paper(7,bill,xxx,theory).
%paper(8,bill,lily,ai).
%paper(9,peter,ann,games).
%reviewer(lily,theory,network).
%reviewer(john,ai,theory).
%reviewer(peter,database,network).
%reviewer(ann,theory,network).
%reviewer(kris,theory,games).
%reviewer(ken,database,games).
%reviewer(bill,database,ai).
%reviewer(jim,theory,games).
%reviewer(kevin,theory,games).
%reviewer(paul,ai,network).
%workLoadAtMost(2).
%?- assign(W1, W2).
%W1 = [john, ken, lily, peter, ken, kris, lily, john, jim],
%W2 = [bill, bill, kris, ann, jim, kevin, ann, paul, kevin].
assign(W1, W2) :-
  papers(PaperIDs),
  gen_domain(W1, W2, N1, N2),
  append(N1, N2, N),
  all_distinct(N),
  maplist(constrain_paper, PaperIDs, N1, N2),
  label(N),
  maplist(reviewer_to_int, N1, W1),
  maplist(reviewer_to_int, N2, W2).


% This predicate does a couple things:
% It makes sure that W1 and W2 are the same length as the number of papers
% It also makes N1, and N2 which are lists of numbers
% which will then be converted into reviewer names for W1 and W2.
% These are also of the same length as the number of papers.
% The domain for each entry in N1 and N2 is restricted so that
% it is between 0 and the number of reviewers times workLoadAtMost - 1 times.
% That way, we can do modulo arithmetic, and all_distinct to assign
% reviewers to papers. 
gen_domain(W1, W2, N1, N2) :-
  count_papers(NumPapers),
  count_reviewers(NumReviewers),
  workLoadAtMost(Max),
  length(W1, NumPapers),
  length(W2, NumPapers),
  length(N1, NumPapers),
  length(N2, NumPapers),
  R is NumReviewers * Max,
  Range is R - 1,
  N1 ins 0..Range,
  N2 ins 0..Range.

% This predicate takes in 2 numbers, each corresponding to one reviewers,
% and it ensures that the constraints defined in the assignment question are
% satisfied.
%
% We check that the first number is less than the second number because it
% reduces the search space, even though the overall answer would not change.
% Then, we convert the reviewer numbers to the reviewer names, and make sure
% that no author is reviewing their own paper, and that the reviewers
% assigned have that subject area in their definitions
%
% This predicate is used with maplist in the assignPaper predicate, so
% that the papers at each index is checked with this predicate.
constrain_paper(Index, Rev1Num, Rev2Num) :-
  Rev1Num #< Rev2Num,
  count_reviewers(NumReviewers),
  Rev1Mod #= Rev1Num mod NumReviewers,
  Rev2Mod #= Rev2Num mod NumReviewers,
  Rev1Mod #< Rev2Mod,
  Rev1Mod #\= Rev2Mod,
  paper(Index, Author1, Author2, Subject),
  reviewer_to_int(Rev1Num, Rev1Name),
  reviewer_to_int(Rev2Num, Rev2Name),
  reviewer(Rev1Name, Sub1, Sub2),
  reviewer(Rev2Name, Sub3, Sub4),
  Author1 \= Rev1Name, 
  Author1 \= Rev2Name, 
  Author2 \= Rev1Name, 
  Author2 \= Rev2Name,
  one_of_subject(Subject, Sub1, Sub2, Sub3, Sub4).

% This predicate takes a reviewer number, and converts it to a reviewer name
% Modulo arithmetic is done, because we expanded the range of numbers for
% reviewers, and multiple numbers need to map to a single reviewer.
% For example, if there were 10 reviewers, the numbers 1 and 11 would map to the 
% second reviewer in the list.
reviewer_to_int(Int, Name) :-
  reviewers(L),
  count_reviewers(NumReviewers),
  Index #= Int mod NumReviewers,
  nth0(Index, L, Name).

% This predicate counts how many papers there are
count_papers(Count) :-
  aggregate_all(count, paper(_,_,_,_), Count).

% This predicate counts how many reviewers there are
count_reviewers(Count) :-
  aggregate_all(count, reviewer(_, _, _), Count).

% This predicate makes L a list of all of the paper IDs
papers(L) :-
  findall(ID, paper(ID, _, _, _), L).

% This predicate makes L a list of all the reviewer names
reviewers(L) :-
  findall(R, reviewer(R, _, _), L).

% This predicate makes sure that both reviewers have the subject in one of
% their subject fields
one_of_subject(S, S1, _, S3, _) :-
  S = S1,
  S = S3.
one_of_subject(S, _, S2, _, S4) :-
  S = S2,
  S = S4.
one_of_subject(S, _, S2, S3, _) :-
  S = S2,
  S = S3.
one_of_subject(S, S1, _, _, S4) :-
  S = S1,
  S = S4.

/*
The four square problem:
Given a natural number N, Sol is bound to a list of 4 or fewer numbers
so that the sum of their squares equals N
,*/

f_sq(N,Sol) :-
   length(L,4),
   L ins 0..N,
   constraint0(N,L),
   label(L),
   removeZero(L,Sol).

constraint0(N,[S1,S2,S3,S4]) :-
   N #= S1*S1 + S2*S2 + S3*S3 + S4*S4,
   S1 #=< S2, S2 #=< S3, S3 #=< S4.
     % this removes some redundant solutions

removeZero([],[]).
removeZero([0|L],L1) :-
   !,
   removeZero(L,L1).
removeZero([A|L],[A|L1]) :-
   removeZero(L,L1).

% find all solutions.
fsq_all(N,L) :- findall(Sol,f_sq(N,Sol),L).

%Given a list L of elements, each of which represents a course and its enrollment, e.g.[cmput325, [john, lily, ken,...]], define a predicate
%courses_taken(+L,+Name,-Courses)

courses_taken([], _, []).
courses_taken([[Course, List] | L], Name, [Course, | Rest]) :-
    member(Name, List),
    !,
    courses_taken(L, Name, Rest).
courses_taken([_ | L], Name, R) :-
    courses_taken(L, Name, R).
#+end_src

#+begin_src sh :exports none :results none
cd code_examples
curl -Lo knight_tour.pl https://raw.githubusercontent.com/triska/clpfd/master/knight_tour.pl
curl -Lo magic_hexagon.pl https://raw.githubusercontent.com/triska/clpfd/master/magic_hexagon.pl
curl -Lo magic_square.pl https://raw.githubusercontent.com/triska/clpfd/master/magic_square.pl
curl -Lo n_factorial.pl https://raw.githubusercontent.com/triska/clpfd/master/n_factorial.pl
curl -Lo n_queens.pl https://raw.githubusercontent.com/triska/clpfd/master/n_queens.pl
curl -Lo sendmory.pl https://raw.githubusercontent.com/triska/clpfd/master/sendmory.pl
curl -Lo sudoku.pl https://raw.githubusercontent.com/triska/clpfd/master/sudoku.pl
curl -Lo tasks.pl https://raw.githubusercontent.com/triska/clpfd/master/tasks.pl
#+end_src


#+include: "code_examples/knight_tour.pl" src prolog
#+include: "code_examples/magic_hexagon.pl" src prolog
#+include: "code_examples/magic_square.pl" src prolog
#+include: "code_examples/n_factorial.pl" src prolog
#+include: "code_examples/n_queens.pl" src prolog
#+include: "code_examples/sendmory.pl" src prolog
#+include: "code_examples/sudoku.pl" src prolog
#+include: "code_examples/tasks.pl" src prolog
*** True/False
- (true ) prolog's backtracking is useful for a CLP solver
- (false) CLP is more general than logic programming
- (false) all variable sin a constraint problem have the same domain
- (true ) a variable domain in CLPFD must be a range of consecutive integers
- (true ) a constraint problem can be solved with C or Java
- (true ) current CLP systems are useful for industrial applications
- (false) a problem with 2 contradictory constraints can still have a solution
- (false) CLP is designed to replace all previous forms of logic programming
- (true ) CLP can be 1 million times more efficient than prolog backtracking
- (false) CLPFD contains one fixed strategy for assigning values to variables
   
** Foundations of logic programming
- Herbrand universe :: The set of all ground terms
*** True/false
Let P be a program consisting of Horn clauses,
let H be its Herbrand universe, and
let B be the Herbrand base of P.
Let the minus sign ‘-’ stand for logical negation
- (false) A Horn clause has at most one negative literal
- (false) p→ (a ∨ b) is a Horn clause
- (true ) (a ∨ b) → p is a Horn clause
- (true ) an atom is a literal
- (true ) a negated atom is a literal
- (true ) any subset of B is an interpretation of P
- (true ) B is a model of P
- (false) the empty set is always a model of P
- (true ) -∀x p(x)  is logically equivalent to ∃x -p(x)
  
  
** Constraint logic programming
** Constraint satisfaction problem
- 3 ingredients
  1. Variables
  2. domains
  3. constraints
- constraint store :: a collection of the primitive constraints, decomposed from user specified constraints.
  it is checked at runtime for consistency whenever the state of these constraints is changed
  (like when a variable is assigned a value)

** Answer set Programming

*** Syntax
#+begin_example
:- is a constraint
you apply things you do NOT want to happen here
i.e. if the thing after :- is true, it cannot happen

a ferry cannot be at 2 different locations at the same time
:- at(ferry, Loc, T), at(ferry, Loc1, T), Loc != Loc1.

two different cars cannot board the same location at the same time
:- board(Car1, Loc, T), board(Car2, Loc, T), Car1 != Car2.
#+end_example
*** Ground vs not ground
- grounding :: the process of translating a non-groud program to a ground one
- if you have variables, it's ground
- if it's the same function, but with concrete numbers/atoms in place of a variable, it's grounded

*** Problems
**** Elevator problem
- elevator transports passengers from initial floors to goal floors
- when it stops at a floor, any passenger can board or unboard
- the goal is to transport all passengers to their destination floors
**** Gripper problem
- transport all the balls from one room to another
- robot is allowed to move form one room to the other and use its 2 grippers to pick up and put down balls
**** Blocks world
- build one or more vertical stacks of blocks
- only one block moved at a time
- block can be placed on the table or on top of another block
- blocks that are under other blocks cannot be moved
**** N queens problem
n_queens problem
#+begin_src asp
#show q/2.
d(1..queens).
1 {q(X,Y):d(Y)} 1 :-d(X).
:- d(X), d(Y), d(X1), q(X,Y), q(X1,Y), X1 != X.
:- d(X), d(Y), d(Y1), q(X,Y), q(X,Y1), Y1 != Y.
% the above is not needed logically
:- d(X), d(Y), d(X1), d(Y1), q(X,Y), q(X1,Y1),
X != X1, Y != Y1, abs(X -X1) == abs(Y -Y1).
:-d(Y), not hasq(Y).
hasq(Y) :-d(X), d(Y), q(X,Y).
#+end_src
*** Ferry problem
#+begin_src asp
move(ferry, From, To, Time)
board(Car, Location, Time)
unboard(Car, Location, Time)
at(Object, Location, Time) % object is at Location at Time
in(ferry, Car, T) % Car is in ferry at Time
empty(ferry, T) % ferry is empty at Time
moving(ferry, T) % don't care about location at Time
affected(Object, T) % Object is affected by some action at Time

% constrains

% ferry cannot be moved to 2 different locations at the same time
:- at(ferry, Loc, T), at(ferry, Loc1, T), Loc != Loc1.

% two cars cannot be boarded at the same time and location
:- board(Car1, Loc, T), board(Car2, Loc, T), Car1 != Car2.
#+end_src

#+begin_src clingo
%Name: Arun Woosaree
%Student Number: 1514457
%Course: CMPUT 325
%Section: B1
%Assignment 4

% Initially, there are cars at various locations, and there is a
% ferry at some location. The ferry can only transport one car at
% a time and the goal is to transport all cars to their
% destinations. No paralell actions are allowed.

#show board/3.
#show move/4.
#show unboard/3.
%#show at/3.
%#show in/3.
%#show moving/3.


time(0..steps).

% Clingo processes "safe programs": any variable occuring in a
% negative literal of rule r must appear in a positive atom in the body of r.
%
% There is nothing wrong to use domains predicates. One may first write
% these predicates and then comment the unnessary ones out (as shown).
% Nothing wrong to leave them there.
% Not all of them can be removed, specially when there is a possibility
% a variable can be instantiated (during grounding) to something unintended.
% You may discover this during debugging using the "#show" diretive.


% actions
{board(Car,Loc,T)} :-
        car(Car),
%       location(Loc), time(T),
        empty(ferry,T),
        at(Car,Loc,T),
        at(ferry,Loc,T),
        not moving(ferry,Loc,T),
        not goal(T).

{unboard(Car,Loc,T)} :-
        car(Car),
%       location(Loc), time(T),
        in(ferry,Car,T),
        at(ferry,Loc,T),
        not moving(ferry,Loc,T),
        not goal(T).

{move(ferry,From,To,T)} :-
%       car(Car),location(From), time(T),
        location(To),
        at(ferry,From,T),
        From != To,
        not goal(T).

moving(ferry,From,T):-     % irrelevant of where ferry moves to
%       location(From),location(Loc), time(T),
        at(ferry,From,T),
        move(ferry,From,Loc,T).

% Below is the wrong code to define empty: it says if there exists
% a Car not in ferry, then ferry is empty.
%
% empty(ferry,T):-
%       car(Car), time(T),
%       not in(ferry,Car,T).

empty(ferry,T):- time(T), not occupied(ferry,T).
occupied(ferry,T) :- in(_,_,T).


%fluents
in(ferry,Car,T+1):-   %an action causes a property to hold
%       car(Car), location(Loc), time(T),
        at(ferry,Loc,T),
        board(Car,Loc,T).

in(ferry,Car,T+1):-
%       car(Car),
        time(T),
        in(ferry,Car,T),
        not affected0(Car,T).

affected0(Car,T) :-
%       time(T), car(Car), location(Loc),
        unboard(Car,Loc,T).

% !!! Cannot replace the above by below - it says that
% Car is in ferry at T+1 if at T there is a location Loc
% s.t. Car is not unboarded - not intended!
%
% in(ferry,Car,T+1):-
%        car(Car), time(T),
%        in(ferry,Car,T),
%        not unboard(Car,Loc,T).

at(ferry,Loc,T+1):-
%       car(Car), location(Loc), time(T),
        at(ferry,Loc,T),
        board(Car,Loc,T).

at(ferry,Loc,T+1):-
%       car(Car), location(Loc), time(T),
        at(ferry,Loc,T),
        unboard(Car,Loc,T).

at(ferry,Loc,T+1):-
%       location(Loc),
        time(T),
        at(ferry,Loc,T), %if we don't have tis line, what could happen?
                         %A: ferry can be everywhere
        not moving(ferry,Loc,T).

at(ferry,To,T+1):-
%       location(To),location(From),
        time(T),
        at(ferry,From,T),
        move(ferry,From,To,T).

at(Car,Loc,T+1):-
        car(Car),  % not commented out - don't want Car instantied to ferry
%       location(Loc), time(T),
        unboard(Car,Loc,T).

at(Car,Loc,T+1):-    %frame axiom
        car(Car), location(Loc), time(T),
        at(Car,Loc,T),
        not board(Car,Loc,T).

goal(T+1):-  time(T), goal(T).
     %once goal is achieved, goal(T) is true for all T > k.

goal :- time(T), goal(T).
:- not goal.


% The code above works for the input file, ferryIn0.lp and ferryIn1.lp,
% but not ferryIn2.lp.
%
% Discover what is wrong. Consider adding the following constraints:
%
% 1. ferry cannot be moved to two different locations at the same time
% 2. it's not possible to board different cars at the same time and same location.

% I think this code is pretty self explanatory
% we add constraints that are exactly as described above

:- at(ferry, Loc, T), at(ferry, Loc1, T), Loc != Loc1.
:- board(Car1, Loc, T), board(Car2, Loc, T), Car1 != Car2.

#+end_src
