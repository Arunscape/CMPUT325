<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-04-20 Tue 13:11 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="author" content="Arun Woosaree" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2cc105e">1. Pre midterm stuff</a>
<ul>
<li><a href="#org6193624">1.1. SECD virtual machine</a></li>
<li><a href="#org5c083f6">1.2. Context based interpreter</a></li>
<li><a href="#org990d4b4">1.3. Lambda calculus</a>
<ul>
<li><a href="#org430c384">1.3.1. Orders of reduction</a></li>
<li><a href="#org32a32f1">1.3.2. Truth table</a></li>
</ul>
</li>
<li><a href="#orge817c3f">1.4. Lisp</a>
<ul>
<li><a href="#org3430c60">1.4.1. Useful functions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6b253b5">2. Post midterm stuff</a>
<ul>
<li><a href="#orgb19aca4">2.1. Prolog</a>
<ul>
<li><a href="#orgf2a7e10">2.1.1. Code examples</a></li>
<li><a href="#orgce308f6">2.1.2. True/False</a></li>
</ul>
</li>
<li><a href="#org12cf9e9">2.2. Foundations of logic programming</a>
<ul>
<li><a href="#org62505d4">2.2.1. True/false</a></li>
</ul>
</li>
<li><a href="#orgb0beefc">2.3. Constraint logic programming</a></li>
<li><a href="#orgad591da">2.4. Constraint satisfaction problem</a></li>
<li><a href="#orgf8349f6">2.5. Answer set Programming</a>
<ul>
<li><a href="#org53a4c67">2.5.1. Syntax</a></li>
<li><a href="#org63bc296">2.5.2. Ground vs not ground</a></li>
<li><a href="#org480e4b1">2.5.3. Problems</a></li>
<li><a href="#orgf231af3">2.5.4. Ferry problem</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org2cc105e" class="outline-2">
<h2 id="org2cc105e"><span class="section-number-2">1</span> Pre midterm stuff</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org6193624" class="outline-3">
<h3 id="org6193624"><span class="section-number-3">1.1</span> SECD virtual machine</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li><a href="https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830027">https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830027</a></li>
<li><a href="https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830028">https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830028</a></li>
</ul>


<pre class="example" id="org802662e">
(lambda (x y) (if (eq x y) x (+ 1 y)))
(LDF
  ( LD (1.2) LD (1.1) EQ SEL (LD (1.1)) (LD (1.2) LDC 1 ADD)
  RTN ))
(LDF (LD (1.2) LD (1.1) EQ SEL (LD (1.1) JOIN) (LD (1.1) ((LD 1.2) LDC 1 + JOIN))
             RTN) )
</pre>

<pre class="example" id="org6a8e260">
(lambda (x y) ((lambda (z) (+ x y z)) 6))
Note that the body of the outside lambda function is an application ((lambda (z) (+ x y z)) 6)),
where the operator + is generic, just like the same operator in lisp.
To decompose the over-all task, you should first show the SECD code for this expression and denote it by, e.g.,e’.
Then, plug it into the full solution.
Answer: e’ = (NIL LDC 6 CONS LDF (LD (2.1) LD (1.2) LD (1.1) ADD RTN) AP)
Then, the full solution is:(LDF e’ || (RTN))
</pre>

<pre class="example" id="org36ba7e2">
(lambda (x) ((lambda (z) (+ x x z)) 4))
Note that the body of the outside lambda function is an application((lambda (z) (+ x x z)) 4)).
To decompose the overall task, you should first show the SECD code for this expression anddenote it by, e.g.,e’.
Then, plug it into the full solution.
Answer:(LDF)  (e’ || (RTN)), where e’is
e = (NIL LDC 4 CONS (LDF (LD (2.1) LD (1.1) LD (1.1) ADD RTN) ) AP
</pre>
</div>
</div>
<div id="outline-container-org5c083f6" class="outline-3">
<h3 id="org5c083f6"><span class="section-number-3">1.2</span> Context based interpreter</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li><a href="https://eclass.srv.ualberta.ca/pluginfile.php/7064969/mod_page/content/3/Problem3_V1.pdf">https://eclass.srv.ualberta.ca/pluginfile.php/7064969/mod_page/content/3/Problem3_V1.pdf</a></li>
<li><a href="https://eclass.srv.ualberta.ca/pluginfile.php/7064969/mod_page/content/3/Problem%203%20Version%202.pdf">https://eclass.srv.ualberta.ca/pluginfile.php/7064969/mod_page/content/3/Problem%203%20Version%202.pdf</a></li>
<li><a href="https://eclass.srv.ualberta.ca/pluginfile.php/7064969/mod_page/content/3/Problem%203%20Version%203.pdf">https://eclass.srv.ualberta.ca/pluginfile.php/7064969/mod_page/content/3/Problem%203%20Version%203.pdf</a></li>
</ul>
<pre class="example" id="org3ce8994">
((lambda (f) (f 2 3)) (lambda (x y) (* x (+ y 1))))

context when (f 2 3) is evaluated (initial context is CT0)
{f -&gt; [(lambda (x y) (* x (+ y 1))), CT0]} U CT0

context when (* x (+ y 1)) is evaluated
{x -&gt; 2, y -&gt; 3} U CT0
</pre>

<pre class="example" id="org1d4d150">
eval
    ((lambda (f x) (cons z (f x x))) (lambda (u v) (cons u v)) 5)
in CT0

CT0 = {z -&gt; 2}

context when (cons z (f x x)) is evaluated
A: Let e1 denote(lambda (u v) (cons u v)).
Then, eval(cons z (f x x))in the context{f→[e1, CT0], x→5}∪CT0
where[e1, CT0] denotes the corresponding closure. Denote this context by CT1.

context when(f x x) is evaluated
A: Continuing the above, eval(f x x)in CT1.
Also, eval z in CT1 (not part of thequestion), which yields 2.

context when(cons u v) is evaluated
A: Continuing the above, eval f in CT1 gives [e1, CT0]
and eval(x x)in CT1 gives(5 5)
Now, apply the function ine1and we have eval(cons u v)in the context{u→5, v→5}∪CT0
===
Overall result is
Two applications of cons gives us (2 . (5 . 5)), or you can simplify it to (2 5 . 5).
</pre>
</div>
</div>


<div id="outline-container-org990d4b4" class="outline-3">
<h3 id="org990d4b4"><span class="section-number-3">1.3</span> Lambda calculus</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org430c384" class="outline-4">
<h4 id="org430c384"><span class="section-number-4">1.3.1</span> Orders of reduction</h4>
<div class="outline-text-4" id="text-1-3-1">
</div>
<ol class="org-ol">
<li><a id="orgfd86272"></a>Applicative order<br />
<div class="outline-text-5" id="text-1-3-1-1">
<p>
arguments are evaluated before a function is applied
</p>

<p>
the innermost leftmost function is applied first
</p>
</div>
</li>
<li><a id="org130c659"></a>Normal order<br />
<div class="outline-text-5" id="text-1-3-1-2">
<p>
the outermost leftmost function is evaluated first&rsquo;
</p>

<p>
normal order has better termination
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org32a32f1" class="outline-4">
<h4 id="org32a32f1"><span class="section-number-4">1.3.2</span> Truth table</h4>
<div class="outline-text-4" id="text-1-3-2">
<pre class="example" id="org2701237">
truth table practice
Lxy|xNM
if x is true then N else M

NOT = (λ B : B F T)
AND = (λ A B : A B F)
OR = (λ A B : A T B)

(λ x : x)(λ x : x) does not reduce to a(λ x : x). It is in normal form.

x y | output
T T | F
T F | F
F T | F
F F | F
(Lxy|F)

x y | output
T T | F
T F | F
F T | F
F F | T
(Lxy|xF(NOT y)

x y | output
T T | F
T F | F
F T | T
F F | F
(Lxy|xFy)


x y | output
T T | F
T F | F
F T | T
F F | T
(Lxy|xFT)

x y | output
T T | F
T F | T
F T | F
F F | F
(Lxy|yFx)

x y | output
T T | F
T F | T
F T | F
F F | T
(Lxy|yFT)

x y | output
T T | F
T F | T
F T | T
F F | F
(Lxy|x(NOT y)y)

x y | output
T T | F
T F | T
F T | T
F F | T
(Lxy|y(NOT x)T)
(*Lxy|x(NOT y)T)

x y | output
T T | T
T F | F
F T | F
F F | F
(Lxy|xyF)

x y | output
T T | T
T F | F
F T | F
F F | T
(Lxy|xy(NOT y)

x y | output
T T | T
T F | F
F T | T
F F | F
(Lxy|y)

x y | output
T T | T
T F | F
F T | T
F F | T
(Lxy|xyT)

x y | output
T T | T
T F | T
F T | F
F F | F
(Lxy|x)

x y | output
T T | T
T F | T
F T | F
F F | T
(Lxy|xT(NOT y))

x y | output
T T | T
T F | T
F T | T
F F | F
(Lxy|xTy)

x y | output
T T | T
T F | T
F T | T
F F | T
(Lxy|T)
</pre>
</div>
</div>
</div>

<div id="outline-container-orge817c3f" class="outline-3">
<h3 id="orge817c3f"><span class="section-number-3">1.4</span> Lisp</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org3430c60" class="outline-4">
<h4 id="org3430c60"><span class="section-number-4">1.4.1</span> Useful functions</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #5B6268;">;; </span><span style="color: #5B6268;">useful functions</span>


(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">xmember</span> (X Y<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
   ((not Y) nil<span style="color: #5B6268;">)</span>
   ((equal X (car Y)) t<span style="color: #5B6268;">)</span>
   (t (xmember X (cdr Y<span style="color: #5B6268;">)))))</span>

(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">xcomplement</span> (S1 S2<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
    ((null S1) nil<span style="color: #5B6268;">)</span>
    ((xmember (car S1) S2) (xcomplement (cdr S1) S2<span style="color: #5B6268;">))</span>
    (t (cons (car S1) (xcomplement (cdr S1) S2<span style="color: #5B6268;">)))))</span>
(<span style="color: #ECBE7B;">assert</span> (equal (xcomplement '(a b c d e) '(a c)) '(b d e<span style="color: #5B6268;">)))</span>

(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">xfilter</span> (test L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
    ((null L) nil<span style="color: #5B6268;">)</span>
    ((funcall test (car L)) (cons (car L) (xfilter test (cdr L<span style="color: #5B6268;">))))</span>
    (t (xfilter test (cdr L<span style="color: #5B6268;">)))))</span>

(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">xrotate</span> (L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">if</span> (null L) nil
      (append (cdr L) (list (car L<span style="color: #5B6268;">)))))</span>
(<span style="color: #ECBE7B;">assert</span> (equal (xrotate '(<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">4</span>)) '(<span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">4</span> <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #5B6268;">)))</span>

(cdr '(<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span><span style="color: #5B6268;">))</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">xrotateAll</span> (L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">if</span> (atom L) L
      (xrotate (mapcar 'xrotateAll L<span style="color: #5B6268;">))))</span>
(<span style="color: #ECBE7B;">assert</span> (equal (xrotateAll '(a b (<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">4</span>) (c d))) '(b (<span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">4</span> <span style="color: #da8548; font-weight: bold;">1</span>) (d c) a<span style="color: #5B6268;">)))</span>
(<span style="color: #ECBE7B;">assert</span> (equal (xrotateAll '((a b) () (<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">4</span>) c d)) '(nil (<span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">4</span> <span style="color: #da8548; font-weight: bold;">1</span>) c d (b a<span style="color: #5B6268;">))))</span>
(<span style="color: #ECBE7B;">assert</span> (equal (xrotateAll '(a b nil (<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> (<span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">4</span>)))) '(b nil (<span style="color: #da8548; font-weight: bold;">2</span> (<span style="color: #da8548; font-weight: bold;">4</span> <span style="color: #da8548; font-weight: bold;">3</span>) <span style="color: #da8548; font-weight: bold;">1</span>) a<span style="color: #5B6268;">)))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">it flattens lists with sublists of any depth such that the result is just a list of atoms</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">assumes that NIL will not appear in the list given</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">Test cases (the test-case function is in a comment at the end of this file)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 2.1 (flatten '(a (b c) d)) '(a b c d))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 2.2 (flatten '((((a))))) '(a))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 2.3 (flatten '(a (b c) (d ((e)) f))) '(a b c d e f))</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">flatten</span> (X<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
    ((null X) nil<span style="color: #5B6268;">)</span>
    ((atom (car X)) (cons (car X) (flatten (cdr X<span style="color: #5B6268;">))))</span>
    (t (append (flatten (car X)) (flatten (cdr X<span style="color: #5B6268;">))))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">it removes duplicate items from a list, preserving the order of elements</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">assumes that NIL will not appear in the list given</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 3.1 (remove-duplicate '(a b c a d b)) '(c a d b)) ;abcd is also a valid order</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">remove-duplicate</span> (X<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
   ((not X) nil<span style="color: #5B6268;">)</span>
   ((xmember (car X) (cdr X)) (remove-duplicates (cdr X<span style="color: #5B6268;">)))</span>
   (t (cons (car X) (remove-duplicates (cdr X<span style="color: #5B6268;">))))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">it mixes the elements of L1 and L2, interweaving them</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">if one list is shorter than the other, append remaining elements to the end</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">mix</span> (L1 L2<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
   ((not L2) L1<span style="color: #5B6268;">)</span>
   ((not L1) L2<span style="color: #5B6268;">)</span>
   (t (cons (car L1) (mix L2 (cdr L1<span style="color: #5B6268;">))))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">it returns all the subsets of a given set</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">allsubsets</span> (L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">if</span> (null L) (list nil<span style="color: #5B6268;">)</span>
    (gen-subsets (car L) (allsubsets (cdr L<span style="color: #5B6268;">)))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">What does this function do?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">it generates subsets for a given list</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">How does the function work?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">I got the algorithm from wikipedia:  https://en.wikipedia.org/wiki/Power_set#Recursive_definition</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">For a non-empty set S (assignment calls it L)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">let e be any element of the set (car L), which we get from allsubsets above</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">and T is the relative complement of e</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">then the power set of S is a union of a power set of T and</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">a power set of T whose each element is expanded with e</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">gen-subsets</span> (e Tcomplement<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">if</span> (not Tcomplement) nil
    (cons
     (cons e (car Tcomplement<span style="color: #5B6268;">))</span>
     (cons (car Tcomplement) (gen-subsets e (cdr Tcomplement<span style="color: #5B6268;">))))))</span>


<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">QUESTION 6</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">Part 1</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">What does this function do?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">given a list L, which is a list of pairs representing linkage</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">and x, the page to start at</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">it returns a list of all webpages that are reachable if you start at x, and follow links to other pages</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">How does the function work?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">it finds all the websites that can be reached, then removes duplicate items</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">and also x, if it is present (see remove-x)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">see find-links</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">Test cases (the test-case function is in a comment at the end of this file)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.11 (reached 'google '( (google shopify) (google aircanada) (amazon aircanada))) '(SHOPIFY AIRCANADA))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.12 (reached 'google '( (google shopify) (shopify amazon) (amazon google) ) ) '(amazon shopify))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.13 (reached 'google '( (google shopify) (shopify amazon) (amazon indigo)  )) '(INDIGO amazon shopify))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.14 (reached 'google '( (google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google) ))  '(SHOPIFY delta AIRCANADA))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.14 (reached 'google '( (google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google) ))  '(SHOPIFY delta AIRCANADA))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">;;backwards reached</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.15 (reached 'google '((shopify aircanada) (google shopify))) '(aircanada shopify))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">;; cycle</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.16 (reached 'a '((a b) (b a) (a c))) '(b c))</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">reached</span> (x L<span style="color: #5B6268;">)</span>
  (remove-duplicate
   (remove-x x
             (find-links x L L nil<span style="color: #5B6268;">))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">What does this function do?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">given x, and a list L, it will remove occurrences of x in L</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">How does the function work?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">it checks each item in the list, and if x is equal to that item, we ignore it</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">and recurse on (cdr l)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">otherwise, we include the item, and remove duplicates from the rest of the list</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">remove-x</span> (x L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
   ((null L) nil<span style="color: #5B6268;">)</span>
   ((eq x (car L)) (remove-x x (cdr L<span style="color: #5B6268;">)))</span>
   (t (cons (car L) (remove-x x (cdr L<span style="color: #5B6268;">))))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">What does this function do?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">it finds all of the places that can be reached</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(see the description for reached)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">the difference here, is that there can be duplicates,</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">and the starting point x, can also be included in the result</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">in reached, these are removed from the result returned by this function</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">How does the function work?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">x is the starting point to search</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">L is the given list of links</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">original is the original list of links. It starts out being the same as L,</span>
<span style="color: #5B6268;">;;  </span><span style="color: #5B6268;">but because we need to check each pair, we use L to go over each element in the list</span>
<span style="color: #5B6268;">;;  </span><span style="color: #5B6268;">and when we need the original list, we pass that in.</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">visited is a list to keep track of websites we have visited</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">if we've already visited the site, then we return nil</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">if we've exhausted all elements, we return x in a list,</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">if there are still items in L, we recursively build that list</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">so the end result contains all of the websites visited</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(caar L) is the first website in the first element of the list given</span>
<span style="color: #5B6268;">;;  </span><span style="color: #5B6268;">e.g. (caar '((a b) (c d))) should give a</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(cadar L) is the second website in the first element of the list given</span>
<span style="color: #5B6268;">;;  </span><span style="color: #5B6268;">e.g. (caar '((a b) (c d))) should give b</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">when recursively building this list, we check if x is equal to (caar L)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">which means that the website x links to somewhere else</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">we get that using (cadar L) and then recursively find out which</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">websites (cadar L) links to since those can also be reached from x</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">we also search the rest of the list, since x could link to other places later</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">in the list</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">find-links</span> (x L original visited<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
   ((null L) (list x)) <span style="color: #5B6268;">; done iteration, ran out of items</span>
   ((xmember x visited) nil<span style="color: #5B6268;">)</span>
   ((eq x (caar L)) (append (find-links (cadar L) original original (cons x visited<span style="color: #5B6268;">))</span>
                            (find-links x (cdr L) original visited<span style="color: #5B6268;">)))</span>
   (t (find-links x (cdr L) original visited<span style="color: #5B6268;">))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">QUESTION 6</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">Part 2</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">What does this function do?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">given S, which is a list of websites</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">L, which is a list of pairs representing linkage between websites,</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">this returns a permutation of S, such that the websites</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">with the most links to it is first in the list</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">if 2 pages are equally important, the order does not matter</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">a site referring to itself does not count</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">and a multiple references to a site from another same site only counts once</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">How does the function work?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">first, we count the references to each site using get-rank (see below)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">then, we sort it using mySort, which sorts based on the number of references counted</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">finally, we get rid of the counts, and return just the final sorted list of</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">elements that were originally in S</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">Test cases (the test-case function is in a comment at the end of this file)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.221 (rank '(google shopify aircanada amazon) '((google shopify) (google aircanada) (amazon aircanada))) '(AIRCANADA SHOPIFY GOOGLE AMAZON))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.222 (rank '(google shopify amazon) '((google shopify) (shopify amazon) (amazon google))) '(GOOGLE SHOPIFY AMAZON))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.223 (rank '(google shopify amazon indigo) '((google shopify) (shopify amazon) (amazon indigo))) '(SHOPIFY AMAZON INDIGO GOOGLE))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.224 (rank '(google shopify aircanada amazon delta) '((google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google))) '(AIRCANADA SHOPIFY DELTA GOOGLE AMAZON))</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">rank</span> (S L<span style="color: #5B6268;">)</span>
  (map-get-cars
   (mySort
    (get-rank S L<span style="color: #5B6268;">))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">I can't use mapcar for this assignment, so this just</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">goes over each element, and maps each pair to just the first element</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">example: ((1 2) (3 4) (5 6)) becomes (1 3 5)</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">map-get-cars</span> (L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">if</span> (null L) nil
    (cons (caar L) (map-get-cars (cdr L<span style="color: #5B6268;">)))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">Custom sort function, this function was given to us on eclass</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">mySort</span> (L<span style="color: #5B6268;">)</span>
  (sort L 'greaterThan<span style="color: #5B6268;">))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">Custom sort function, this function was given to us on eclass</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">it sorts such that the item with the greatest second item in the pair comes first</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">I use cdr instead of cadr here because I end up with a list of dotted pairs, so</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">cdr gets me an atom, which is the second item in the pair</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">greaterThan</span> (L1 L2<span style="color: #5B6268;">)</span>
  (&gt; (cdr L1) (cdr L2<span style="color: #5B6268;">)))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">What does this function do?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">given S, which is a list of websites</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">L, which is a list of pairs representing linkage between websites,</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">this returns a list of pairs, where the first item in the pair comes from list S,</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">and the second item is how many unique links there are to that website</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">How does the function work?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">for each element in S, we count how many references there are to that element (see count-references)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">we then take that element and map it to a pair with the first element being itself, and the second</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">element being the result of count-references</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">Test cases (the test-case function is in a comment at the end of this file)</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.21 (test-rank '(google shopify aircanada amazon) '((google shopify) (google aircanada) (amazon aircanada))) '((AIRCANADA 2) (SHOPIFY 1) (GOOGLE 0) (AMAZON 0)))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.22 (test-rank '(google shopify amazon) '((google shopify) (shopify amazon) (amazon google))) '((GOOGLE 1) (SHOPIFY 1) (AMAZON 1)))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.23 (test-rank '(google shopify amazon indigo) '((google shopify) (shopify amazon) (amazon indigo))) '((SHOPIFY 1) (AMAZON 1) (INDIGO 1) (GOOGLE 0)))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.24 (test-rank '(google shopify aircanada amazon delta) '((google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (google google))) '((AIRCANADA 2) (SHOPIFY 1) (DELTA 1) (GOOGLE 0) (AMAZON 0)))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">;; multiple references don't count and references to self don't count</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(test-case 6.25 (test-rank '(google shopify aircanada amazon delta) '((google shopify) (google aircanada) (amazon aircanada) (aircanada delta) (aircanada aircanada) (aircanada delta) (google google))) '((AIRCANADA 2) (SHOPIFY 1) (DELTA 1) (GOOGLE 0) (AMAZON 0)))</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">this just makes sure that my test cases match the result that i'm expecting it to be equal to</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">since get-rank returns a list of dotted pairs instead of a list of pairs</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(defun test-rank (S L)</span>
<span style="color: #5B6268;">;;   </span><span style="color: #5B6268;">(mapcar (lambda (x) (list (car x) (cdr x)))</span>
<span style="color: #5B6268;">;;           </span><span style="color: #5B6268;">(mySort (get-rank S L))))</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">get-rank</span> (S L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">if</span> (null S) nil
    (cons
     (cons (car S) (count-references (car S) L nil<span style="color: #5B6268;">))</span>
     (get-rank (cdr S) L<span style="color: #5B6268;">))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">What does this function do?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">given x, and a list of pairs L,</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">this counts how many references there are to x in L</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">How does the function work?</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">sources keeps track of the sources which have linked to x</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">that way, we can make sure that we don't add duplicates</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">when we're done iterating through the list L, we return the length of sources</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">else, if x is equal to the second element in the current pair (cadar L), we add</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">the first element (caar L) to the list of sources</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">but first, we need to make sure that it is not already in the list of sources</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">and also that it is not a link to itself</span>
<span style="color: #5B6268;">;;</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">if those conditions are not satisfied, then we search through the rest of L,</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">until it is exhausted</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">count-references</span> (x L sources<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
   ((null L) (len sources<span style="color: #5B6268;">))</span>
   ((and
     (equal x (cadar L<span style="color: #5B6268;">))</span>
     (not (xmember (caar L) sources<span style="color: #5B6268;">))</span>
     (not (eq x (caar L<span style="color: #5B6268;">))))</span>
    (count-references x (cdr L) (cons (caar L) sources<span style="color: #5B6268;">)))</span>
   (t (count-references x (cdr L) sources<span style="color: #5B6268;">))))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">should be self explanatory, but in case it's not:</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">this gives the length of a list by going over each element in it and adding one</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">when the list is empty, we return 0 and add the rest of the ones together</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">len</span> (L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">if</span> (null L) <span style="color: #da8548; font-weight: bold;">0</span>
      (+ <span style="color: #da8548; font-weight: bold;">1</span> (len (cdr L<span style="color: #5B6268;">)))))</span>


<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">TEST CASE HELPER FUNCTION</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">this is commented out because format is not in the list of allowed functions</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">but I used it to run my test cases defined above</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">(defun test-case (ID Test Result)</span>
<span style="color: #5B6268;">;;   </span><span style="color: #5B6268;">(if (equal Test Result)</span>
<span style="color: #5B6268;">;;       </span><span style="color: #5B6268;">(format t "Test ~S OK~%" ID)</span>
<span style="color: #5B6268;">;;       </span><span style="color: #5B6268;">(format t "FAIL: Test ~S expected ~S got ~S~%" ID Result Test)))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">submit these</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">do later</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">xcomplement</span> (S1 S2<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
    ((null S1) nil<span style="color: #5B6268;">)</span>
    ((xmember (car S1) S2) (xcomplement (cdr S1) S2<span style="color: #5B6268;">))</span>
    (t (cons (car S1) (xcomplement (cdr S1) S2<span style="color: #5B6268;">)))))</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">from assignment 1</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">xmember</span> (X Y<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
    ((not Y) nil<span style="color: #5B6268;">)</span>
    ((equal X (car Y)) t<span style="color: #5B6268;">)</span>
    (t (xmember X (cdr Y<span style="color: #5B6268;">)))))</span>

(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">subset0</span> (S1 S2<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">let</span> ((c (xcomplement S1 S2<span style="color: #5B6268;">)))</span>
    (<span style="color: #51afef;">if</span> (null c) T nil<span style="color: #5B6268;">)))</span>


<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">can be nested</span>
<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">from assignment 1</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">flatten</span> (X<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
    ((null X) nil<span style="color: #5B6268;">)</span>
    ((atom (car X)) (cons (car X) (flatten (cdr X<span style="color: #5B6268;">))))</span>
    (t (append (flatten (car X)) (flatten (cdr X<span style="color: #5B6268;">))))))</span>

(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">min0</span> (L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">let</span> ((flat (flatten L))) (reduce (<span style="color: #51afef;">lambda</span> (x y) (<span style="color: #51afef;">if</span> (&lt; x y) x y)) flat<span style="color: #5B6268;">)))</span>
(min0 '(<span style="color: #da8548; font-weight: bold;">5</span> (<span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">7</span> (<span style="color: #da8548; font-weight: bold;">4</span> <span style="color: #da8548; font-weight: bold;">6</span><span style="color: #5B6268;">))))</span>


<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">todo reduce</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">exam</span> (L<span style="color: #5B6268;">)</span>
  (reduce (<span style="color: #51afef;">lambda</span> (x y) (+ x y<span style="color: #5B6268;">))</span>
          (mapcar
           (<span style="color: #51afef;">lambda</span> (x) (* (+ <span style="color: #da8548; font-weight: bold;">2</span> (car x)) (cdr x))) L<span style="color: #5B6268;">)))</span>
(exam '((<span style="color: #da8548; font-weight: bold;">2</span> . <span style="color: #da8548; font-weight: bold;">5</span>) (<span style="color: #da8548; font-weight: bold;">4</span> . <span style="color: #da8548; font-weight: bold;">3</span>) (<span style="color: #da8548; font-weight: bold;">5</span> . <span style="color: #da8548; font-weight: bold;">8</span><span style="color: #5B6268;">)))</span>


(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">exchange0</span> (L<span style="color: #5B6268;">)</span>
  (mapcar (<span style="color: #51afef;">lambda</span> (x) (cons (cdr x) (car x))) L<span style="color: #5B6268;">))</span>
(exchange0 '((a . b) (c . d) (e . f<span style="color: #5B6268;">)))</span>

<span style="color: #5B6268;">;; </span><span style="color: #5B6268;">rethink this one</span>
(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">swapAll</span> (L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">if</span> (and (atom (car L)) (atom (cdr L<span style="color: #5B6268;">)))</span>
      (cons (cdr L) (car L<span style="color: #5B6268;">))</span>
      (mapcar (<span style="color: #51afef;">lambda</span> (x<span style="color: #5B6268;">)</span>
                (<span style="color: #51afef;">cond</span>
                  ((and (atom (car x)) (atom (cdr x))) (cons (cdr x) (car x<span style="color: #5B6268;">)))</span>
                  ((and (atom (car x)) (not (atom (cdr x)))) (cons (swapAll (cdr x)) (car x<span style="color: #5B6268;">)))</span>
                  ((and (not (atom (car x))) (atom (cdr x))) (cons (cdr x) (swapAll (car x<span style="color: #5B6268;">))))</span>
                  (t (cons (swapAll (cdr x))(swapAll (car x)))))) L<span style="color: #5B6268;">)))</span>

(swapAll '(((a . b) . (c . d)) (e . f<span style="color: #5B6268;">)))</span>
(swapAll '(((a . b) . c) (e . f<span style="color: #5B6268;">)))</span>


(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">is-simple-pair</span> (x<span style="color: #5B6268;">)</span>
  (and (atom (car x)) (atom (cdr x<span style="color: #5B6268;">))))</span>

(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">swapAll</span> (L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
    ((is-simple-pair L) (cons (cdr L) (car L<span style="color: #5B6268;">)))</span>
    (t (cons (<span style="color: #51afef;">if</span> (atom (cdr L<span style="color: #5B6268;">))</span>
                 (cdr L<span style="color: #5B6268;">)</span>
                 (swapAll (cdr L<span style="color: #5B6268;">)))</span>
             (<span style="color: #51afef;">if</span> (atom (car L<span style="color: #5B6268;">))</span>
                 (car L<span style="color: #5B6268;">)</span>
                 (swapAll (car L<span style="color: #5B6268;">)))))))</span>

(<span style="color: #51afef;">defun</span> <span style="color: #c678dd;">swap</span> (L<span style="color: #5B6268;">)</span>
  (<span style="color: #51afef;">cond</span>
    ((atom L) L<span style="color: #5B6268;">)</span>
    (t (cons (<span style="color: #51afef;">if</span> (atom (cdr L)) (cdr L) (swap (cdr L))) (<span style="color: #51afef;">if</span> (atom (car L)) (car L) (swap (car L<span style="color: #5B6268;">)))))))</span>
(swap '(((a . b) . (c . d)) (e . f<span style="color: #5B6268;">)))</span>
(swap '(((a . b) . c) (e . f<span style="color: #5B6268;">)))</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org6b253b5" class="outline-2">
<h2 id="org6b253b5"><span class="section-number-2">2</span> Post midterm stuff</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgb19aca4" class="outline-3">
<h3 id="orgb19aca4"><span class="section-number-3">2.1</span> Prolog</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-orgf2a7e10" class="outline-4">
<h4 id="orgf2a7e10"><span class="section-number-4">2.1.1</span> Code examples</h4>
<div class="outline-text-4" id="text-2-1-1">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #5B6268;">% </span><span style="color: #5B6268;">append(L1,L2,L3): append L1 and L2 to get L3</span>
<span style="color: #c678dd;">append</span>(<span style="color: #51afef;">[]</span>,<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">L</span>).
<span style="color: #c678dd;">append</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>,<span style="color: #dcaeea;">L1</span>,<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L2</span><span style="color: #51afef;">]</span>) :- append(<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">L1</span>,<span style="color: #dcaeea;">L2</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">member(A,L): A is in list L</span>
<span style="color: #c678dd;">member</span>(<span style="color: #dcaeea;">A</span>,<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span>).
<span style="color: #c678dd;">member</span>(<span style="color: #dcaeea;">A</span>,<span style="color: #51afef;">[</span><span style="color: #dcaeea;">B</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>) :- <span style="color: #dcaeea;">A</span> \== <span style="color: #dcaeea;">B</span>, member(<span style="color: #dcaeea;">A</span>,<span style="color: #dcaeea;">L</span>).

<span style="color: #c678dd;">cartesian</span>(<span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">cartesian</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">N</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">M</span>) :-
     pair(<span style="color: #dcaeea;">A</span>,<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">M1</span>),
     cartesian(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">M2</span>),
     append(<span style="color: #dcaeea;">M1</span>, <span style="color: #dcaeea;">M2</span>, <span style="color: #dcaeea;">M</span>).
<span style="color: #c678dd;">cartesian</span>(<span style="color: #51afef;">[</span>a,b<span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span>d,e<span style="color: #51afef;">]</span>, <span style="color: #51afef;">[[</span>a,d<span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span>a,e<span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span>b,d<span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span>b,e<span style="color: #51afef;">]]</span>).

<span style="color: #c678dd;">pair</span>(<span style="color: #dcaeea;">_</span>, <span style="color: #51afef;">[]</span>, <span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">pair</span>(<span style="color: #dcaeea;">A</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">B</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">A</span>,<span style="color: #dcaeea;">B</span><span style="color: #51afef;">]|</span><span style="color: #dcaeea;">N</span><span style="color: #51afef;">]</span> ) :- pair(<span style="color: #dcaeea;">A</span>, <span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">N</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">reverse(X,Y): Y is the reverse of input list X</span>
<span style="color: #c678dd;">reverse</span>(<span style="color: #51afef;">[]</span>, <span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">reverse</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L1</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">L2</span>) :- reverse(<span style="color: #dcaeea;">L1</span>, <span style="color: #dcaeea;">N</span>), append(<span style="color: #dcaeea;">N</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">L2</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">sum(L,N) will have N bound to the sum of the numbers in L.</span>
<span style="color: #c678dd;">sum</span>(<span style="color: #51afef;">[]</span>,<span style="color: #da8548; font-weight: bold;">0</span>).
<span style="color: #c678dd;">sum</span>(<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">N</span>) :- number(<span style="color: #dcaeea;">N</span>), <span style="color: #51afef;">!</span>.
<span style="color: #c678dd;">sum</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>,<span style="color: #dcaeea;">S</span>) :- sum(<span style="color: #dcaeea;">A</span>,<span style="color: #dcaeea;">S1</span>), sum(<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">S2</span>), <span style="color: #dcaeea;">S</span> is <span style="color: #dcaeea;">S1</span> + <span style="color: #dcaeea;">S2</span>.

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">flatten(L,L1): flatten a list of atoms (atoms and numbers) L to a flat list L1.</span>
<span style="color: #c678dd;">flatten</span>(<span style="color: #51afef;">[]</span>,<span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">flatten</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>,<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L1</span><span style="color: #51afef;">]</span>) :-
     xatom(<span style="color: #dcaeea;">A</span>), <span style="color: #51afef;">!</span>, flatten(<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">L1</span>).
<span style="color: #c678dd;">flatten</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>,<span style="color: #dcaeea;">R</span>) :-
     flatten(<span style="color: #dcaeea;">A</span>,<span style="color: #dcaeea;">A1</span>), flatten(<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">L1</span>), append(<span style="color: #dcaeea;">A1</span>,<span style="color: #dcaeea;">L1</span>,<span style="color: #dcaeea;">R</span>).

<span style="color: #c678dd;">xatom</span>(<span style="color: #dcaeea;">A</span>) :- atom(<span style="color: #dcaeea;">A</span>).
<span style="color: #c678dd;">xatom</span>(<span style="color: #dcaeea;">A</span>) :- number(<span style="color: #dcaeea;">A</span>).
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">cut</span>
<span style="color: #c678dd;">x</span> :- p, <span style="color: #51afef;">!</span>, q.
<span style="color: #c678dd;">x</span> :-r.
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">same as if p then q else r</span>

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">setIntersect(+S1,+S2,-S3)</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">this takes in 2 lists of atoms, S1 and S2.</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">S3 is a list of atoms that are in both S1 and S2</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">S1 is always a list of distinct atoms.</span>
<span style="color: #c678dd;">setIntersect</span>(<span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #51afef;">[]</span>). <span style="color: #5B6268;">% </span><span style="color: #5B6268;">if first list is empty return empty list</span>
<span style="color: #c678dd;">setIntersect</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">First</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Rest</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">S2</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">First</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Output</span><span style="color: #51afef;">]</span>) :-
  xmember(<span style="color: #dcaeea;">First</span>, <span style="color: #dcaeea;">S2</span>), setIntersect(<span style="color: #dcaeea;">Rest</span>, <span style="color: #dcaeea;">S2</span>, <span style="color: #dcaeea;">Output</span>). <span style="color: #5B6268;">% </span><span style="color: #5B6268;">if First element of S1 is in S2 then add it to the output list, and check the rest of S1 against S2</span>
<span style="color: #c678dd;">setIntersect</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">_</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">S2</span>, <span style="color: #dcaeea;">A</span>) :-
  setIntersect(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">S2</span>, <span style="color: #dcaeea;">A</span>).
<span style="color: #5B6268;">/*</span>
<span style="color: #5B6268;"> swap(+L, -R)</span>
<span style="color: #5B6268;"> this takes in a list L, and makes it so that R</span>
<span style="color: #5B6268;"> has every 2 elements swapped with each other</span>
<span style="color: #5B6268;">*/</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- begin_tests(question2).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(swap1) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">swap([a,1,b,2], W),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">W = [1,a,2,b].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(swap2) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">swap([a,1,b], W),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">W = [1,a,b].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- end_tests(question2).</span>
<span style="color: #c678dd;">swap</span>(<span style="color: #51afef;">[]</span>, <span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">swap</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">]</span>).
<span style="color: #c678dd;">swap</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span>, <span style="color: #dcaeea;">B</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R1</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">B</span>, <span style="color: #dcaeea;">A</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R2</span><span style="color: #51afef;">]</span>) :-
  swap(<span style="color: #dcaeea;">R1</span>, <span style="color: #dcaeea;">R2</span>). 

<span style="color: #5B6268;">/*</span>
<span style="color: #5B6268;"> filter(+L,+OP,+N,-L1)</span>
<span style="color: #5B6268;"> this takes in L, a possibly nested list of numbers, and outputs L1,</span>
<span style="color: #5B6268;"> which has all of the numbers in L that meet certain criteria.</span>
<span style="color: #5B6268;"> The criteria is defined by OP and N, where OP is "greaterThan", "equal",</span>
<span style="color: #5B6268;"> or "lessThan", and N is a number.</span>
<span style="color: #5B6268;">*/</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- begin_tests(question3).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(filtergreater) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">filter([3,4,[5,2],[1,7,3]],greaterThan,3,W),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">W = [4,5,7].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(filterequal) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">filter([3,4,[5,2],[1,7,3]],equal,3,W),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">W = [3,3].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(filterless) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">filter([3,4,[5,2],[1,7,3]],lessThan,3,W),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">W = [2,1].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- end_tests(question3).</span>

<span style="color: #c678dd;">filter</span>(<span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">filter</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">F</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">OP</span>, <span style="color: #dcaeea;">N</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">F</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Output</span><span style="color: #51afef;">]</span>) :-
  number(<span style="color: #dcaeea;">F</span>),
  doOP(<span style="color: #dcaeea;">F</span>, <span style="color: #dcaeea;">OP</span>, <span style="color: #dcaeea;">N</span>),
  filter(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">OP</span>, <span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">Output</span>).

<span style="color: #c678dd;">filter</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">F</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">OP</span>, <span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">Output</span>) :-
  \+ number(<span style="color: #dcaeea;">F</span>),
  filter(<span style="color: #dcaeea;">F</span>, <span style="color: #dcaeea;">OP</span>, <span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">Out1</span>),
  filter(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">OP</span>, <span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">Out2</span>),
  append(<span style="color: #dcaeea;">Out1</span>, <span style="color: #dcaeea;">Out2</span>, <span style="color: #dcaeea;">Output</span>).

<span style="color: #c678dd;">filter</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">_</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">OP</span>, <span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">Output</span>) :-
  filter(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">OP</span>, <span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">Output</span>).

<span style="color: #c678dd;">doOP</span>(<span style="color: #dcaeea;">X</span>, greaterThan, <span style="color: #dcaeea;">Y</span>) :- <span style="color: #dcaeea;">X</span> &gt; <span style="color: #dcaeea;">Y</span>.
<span style="color: #c678dd;">doOP</span>(<span style="color: #dcaeea;">X</span>, lessThan, <span style="color: #dcaeea;">Y</span>) :- <span style="color: #dcaeea;">X</span> &lt; <span style="color: #dcaeea;">Y</span>.
<span style="color: #c678dd;">doOP</span>(<span style="color: #dcaeea;">X</span>, equal, <span style="color: #dcaeea;">Y</span>) :- <span style="color: #dcaeea;">X</span> =:= <span style="color: #dcaeea;">Y</span>.
<span style="color: #5B6268;">/*</span>
<span style="color: #5B6268;"> countAll(+L,-N)</span>
<span style="color: #5B6268;"> given L, a flat list of atoms, the number of occurences of each atom is counted</span>
<span style="color: #5B6268;"> N is a list of pairs of the form [a,n], where a is the atom and n is the</span>
<span style="color: #5B6268;"> number of occurences. N is sorted in increasing order by n. If n is tied,</span>
<span style="color: #5B6268;"> there is no tie breaking functionality based on what a is.</span>
<span style="color: #5B6268;">*/</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- begin_tests(question4).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(countall) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">countAll([a,b,e,c,c,b],N),(</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">N = [[a,1],[e,1],[b,2],[c,2]];</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">N = [[e,1],[a,1],[b,2],[c,2]]</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">).% other permutations are possible, mine seems to return the second permutation</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- end_tests(question4).</span>

<span style="color: #c678dd;">countAll</span>(<span style="color: #51afef;">[]</span>, <span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">countAll</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">F</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">SortedOutput</span>) :-
  countAll(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">IntermediateOutput</span>),
  incrementCount(<span style="color: #dcaeea;">F</span>, <span style="color: #dcaeea;">IntermediateOutput</span>, <span style="color: #dcaeea;">Output</span>),
  bubble_sort(<span style="color: #dcaeea;">Output</span>, <span style="color: #dcaeea;">SortedOutput</span>).

<span style="color: #c678dd;">incrementCount</span>(<span style="color: #dcaeea;">X</span>, <span style="color: #51afef;">[]</span>, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">X</span>,<span style="color: #da8548; font-weight: bold;">1</span><span style="color: #51afef;">]]</span>).
<span style="color: #c678dd;">incrementCount</span>(<span style="color: #dcaeea;">X</span>, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">CountX</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">CountXPlusOne</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>) :-
  <span style="color: #dcaeea;">CountXPlusOne</span> is <span style="color: #dcaeea;">CountX</span> + <span style="color: #da8548; font-weight: bold;">1</span>.
<span style="color: #c678dd;">incrementCount</span>(<span style="color: #dcaeea;">Y</span>, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">CountX</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">CountX</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">T</span><span style="color: #51afef;">]</span>) :-
  <span style="color: #dcaeea;">X</span> \= <span style="color: #dcaeea;">Y</span>,
  incrementCount(<span style="color: #dcaeea;">Y</span>, <span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">T</span>).

<span style="color: #c678dd;">bubble_sort</span>(<span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">L</span>) :- is_sorted(<span style="color: #dcaeea;">L</span>).
<span style="color: #c678dd;">bubble_sort</span>(<span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">Output</span>) :-
  xappend(<span style="color: #dcaeea;">X</span>, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">A</span>, <span style="color: #dcaeea;">Acount</span><span style="color: #51afef;">]</span>,<span style="color: #51afef;">[</span><span style="color: #dcaeea;">B</span>, <span style="color: #dcaeea;">Bcount</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Y</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">L</span>),
  <span style="color: #dcaeea;">Acount</span> &gt; <span style="color: #dcaeea;">Bcount</span>,
  xappend(<span style="color: #dcaeea;">X</span>, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">B</span>, <span style="color: #dcaeea;">Bcount</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span>, <span style="color: #dcaeea;">Acount</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Y</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">R</span>),
  bubble_sort(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">Output</span>).

<span style="color: #c678dd;">is_sorted</span>(<span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">is_sorted</span>(<span style="color: #51afef;">[[</span><span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span><span style="color: #51afef;">]]</span>).
<span style="color: #c678dd;">is_sorted</span>(<span style="color: #51afef;">[[</span><span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">Acount</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">B</span>,<span style="color: #dcaeea;">Bcount</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>) :-
  <span style="color: #dcaeea;">Acount</span> =&lt; <span style="color: #dcaeea;">Bcount</span>,
  is_sorted(<span style="color: #51afef;">[[</span><span style="color: #dcaeea;">B</span>, <span style="color: #dcaeea;">Bcount</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>).

<span style="color: #5B6268;">/*</span>
<span style="color: #5B6268;"> sub(+L,+S,-L1)</span>
<span style="color: #5B6268;"> this takes in a possibly nested list of atoms L, and a list of pairs S</span>
<span style="color: #5B6268;"> of the form [[x1, e1], ...].</span>
<span style="color: #5B6268;"> L1 is the same as L, except that any occurences of xi is replaced by ei.</span>
<span style="color: #5B6268;"> xi is always an atom</span>
<span style="color: #5B6268;"> ei is an arbitrary expression</span>

<span style="color: #5B6268;"> every xi is assumed to be distinct, and xi will never occur in ei</span>
<span style="color: #5B6268;">*/</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- begin_tests(question5).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(sub) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">sub([a,[a,d],[e,a]],[[a,2]],L),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">L= [2,[2,d],[e,2]].</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(sub2) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">sub([a,b,c], [[a,d], [b, c]], [d, c, c]).</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(sub3) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">sub([a,[b, [c, [d]]]], [[a,z], [z, v], [c, g], [d, p]] , [z,[b, [g, [p]]]]).</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(subexpression) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">sub([a, b, c], [[b, 4 &lt; 1]], [a, 4&lt;1, c]).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- end_tests(question5).</span>

<span style="color: #c678dd;">sub</span>(<span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">sub</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">X</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">S</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">Y</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Output</span><span style="color: #51afef;">]</span>) :- <span style="color: #5B6268;">% </span><span style="color: #5B6268;">is an atom</span>
  atom(<span style="color: #dcaeea;">X</span>),
  find_substitution(<span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">S</span>, <span style="color: #dcaeea;">Y</span>),
  sub(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">S</span>, <span style="color: #dcaeea;">Output</span>).
<span style="color: #c678dd;">sub</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">L</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">S</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">Output</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">ROutput</span><span style="color: #51afef;">]</span>) :- <span style="color: #5B6268;">% </span><span style="color: #5B6268;">not an atom</span>
  sub(<span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">S</span>, <span style="color: #dcaeea;">Output</span>),
  sub(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">S</span>, <span style="color: #dcaeea;">ROutput</span>).

<span style="color: #c678dd;">find_substitution</span>(<span style="color: #dcaeea;">X</span>, <span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">X</span>).
<span style="color: #c678dd;">find_substitution</span>(<span style="color: #dcaeea;">X</span>, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">E</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">E</span>).
<span style="color: #c678dd;">find_substitution</span>(<span style="color: #dcaeea;">X</span>, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">Xi</span>, <span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">S</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">Output</span>) :-
  <span style="color: #dcaeea;">X</span> \= <span style="color: #dcaeea;">Xi</span>,
  find_substitution(<span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">S</span>, <span style="color: #dcaeea;">Output</span>).

<span style="color: #5B6268;">/*</span>
<span style="color: #5B6268;"> allConnected(+L)</span>
<span style="color: #5B6268;"> this takes in a list, and it returns true if every node in L can reach every</span>
<span style="color: #5B6268;"> other node in L</span>

<span style="color: #5B6268;"> How it works:</span>
<span style="color: #5B6268;"> first, an empty list is all connected (base case)</span>

<span style="color: #5B6268;"> then, we check every element in L, and see if it is connected using the</span>
<span style="color: #5B6268;"> allConnected helper predicate defned below</span>
<span style="color: #5B6268;">*/</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- begin_tests(question6).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(allconnected) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">allConnected([a,b,c]).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- end_tests(question6).</span>

<span style="color: #c678dd;">allConnected</span>(<span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">allConnected</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">F</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>) :-
  allConnectedHelper(<span style="color: #dcaeea;">F</span>, <span style="color: #dcaeea;">R</span>),
  allConnected(<span style="color: #dcaeea;">R</span>).

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">allConnectedHelper(-X, -L)</span>
<span style="color: #5B6268;"> this checks if node X is connected to all elements in L</span>

<span style="color: #5B6268;"> How it works:</span>
<span style="color: #5B6268;"> if L is empty, then it is all connected (base case)</span>
<span style="color: #5B6268;"> else we check if X is connected to the first element in L,</span>
<span style="color: #5B6268;"> and also every other element in L by recursing on the tail of L</span>

<span style="color: #5B6268;"> the connected predicate is defined below</span>
<span style="color: #5B6268;"> */</span>
<span style="color: #c678dd;">allConnectedHelper</span>(<span style="color: #dcaeea;">_</span>, <span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">allConnectedHelper</span>(<span style="color: #dcaeea;">X</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">F</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>) :-
  connected(<span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">F</span>),
  allConnectedHelper(<span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">R</span>).

<span style="color: #c678dd;">connected</span>(<span style="color: #dcaeea;">X</span>,<span style="color: #dcaeea;">Y</span>) :-
  edge(<span style="color: #dcaeea;">X</span>,<span style="color: #dcaeea;">Y</span>)<span style="color: #51afef;">;</span>
  edge(<span style="color: #dcaeea;">Y</span>,<span style="color: #dcaeea;">X</span>).

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">clique(+L)</span>
<span style="color: #5B6268;"> The clique problem is a graph-theoretic problem of finding a subset of nodes</span>
<span style="color: #5B6268;"> where each is connected to every other node in the subset. </span>

<span style="color: #5B6268;"> This code is given to us in the assignment</span>
<span style="color: #5B6268;">*/</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">for the node example defined in eclass</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- begin_tests(clique).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(clique) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">clique([a,b,c]).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- end_tests(clique).</span>
<span style="color: #c678dd;">clique</span>(<span style="color: #dcaeea;">L</span>) :- 
  findall(<span style="color: #dcaeea;">X</span>,node(<span style="color: #dcaeea;">X</span>),<span style="color: #dcaeea;">Nodes</span>),
  subset(<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">Nodes</span>), allConnected(<span style="color: #dcaeea;">L</span>).

<span style="color: #c678dd;">subset</span>(<span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>).
<span style="color: #c678dd;">subset</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">X</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Xs</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">Set</span>) :-
  append(<span style="color: #dcaeea;">_</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">X</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Set1</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">Set</span>),
  subset(<span style="color: #dcaeea;">Xs</span>, <span style="color: #dcaeea;">Set1</span>).

<span style="color: #5B6268;">/*</span>
<span style="color: #5B6268;"> convert(+Term,-Result)</span>
<span style="color: #5B6268;"> this takes in a Term, which is a list of atoms</span>
<span style="color: #5B6268;"> anything between two q atoms are kept as-is,</span>
<span style="color: #5B6268;"> while any 'e' outside of two q atoms are dropped,</span>
<span style="color: #5B6268;"> and anything else outside of two q atoms are changed to c</span>

<span style="color: #5B6268;"> for an unmatched q, anything after is considered outside of a q pair, so</span>
<span style="color: #5B6268;"> 'e' will be dropped, and anything else changed to c. This happens when there</span>
<span style="color: #5B6268;"> is an odd number of q atoms</span>

<span style="color: #5B6268;"> How it works:</span>
<span style="color: #5B6268;"> we call the convertHelper predicate defined below, which takes in the same</span>
<span style="color: #5B6268;"> 2 arguments as convert. It also takes in a third argument, which is a boolean</span>
<span style="color: #5B6268;"> to help with keeping track of matching q atoms</span>
<span style="color: #5B6268;">*/</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- begin_tests(question7).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(convert1) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">convert([e,e,a,e,b,e],R),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">R = [c,c].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(convert2) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">convert([e,q,a,b,e,e],R),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">R = [q,c,c].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(convert3) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">convert([e,a,e,e],R),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">R = [c].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(convert4) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">convert([e,q,a,e,b,q,e,a,e],R),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">R = [q,a,e,b,q,c].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(convert5) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">convert([a,q,e,l,q,r,e,q,b,e],R),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">R = [c,q,e,l,q,c,q,c].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(convert6) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">convert([q,e,q,b,q,e,l,q,a,e],R),</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">R = [q,e,q,c,q,e,l,q,c].</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- end_tests(question7).</span>

<span style="color: #c678dd;">convert</span>(<span style="color: #dcaeea;">Term</span>, <span style="color: #dcaeea;">Result</span>) :-
  convertHelper(<span style="color: #dcaeea;">Term</span>, <span style="color: #dcaeea;">Result</span>, false).


<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">convertHelper(+Term, -Result, +Qfound)</span>
<span style="color: #5B6268;"> this is the main logic for convert.</span>
<span style="color: #5B6268;"> this takes in a Term, which is a list of atoms</span>
<span style="color: #5B6268;"> anything between two q atoms are kept as-is,</span>
<span style="color: #5B6268;"> while any 'e' outside of two q atoms are dropped,</span>
<span style="color: #5B6268;"> and anything else outside of two q atoms are changed to c</span>

<span style="color: #5B6268;"> for an unmatched q, anything after is considered outside of a q pair, so</span>
<span style="color: #5B6268;"> 'e' will be dropped, and anything else changed to c. This happens when there</span>
<span style="color: #5B6268;"> is an odd number of q atoms</span>
<span style="color: #5B6268;"> Read the comments for the convert predicate above to see what this does.</span>

<span style="color: #5B6268;"> This has the same input and output arguments as convert. It also takes in a</span>
<span style="color: #5B6268;"> third argument, which is a boolean to help with keeping track of matching q</span>
<span style="color: #5B6268;"> atoms</span>

<span style="color: #5B6268;"> How it works:</span>
<span style="color: #5B6268;"> if Term is empty, then so is the result (base case)</span>
<span style="color: #5B6268;"> </span>
<span style="color: #5B6268;"> next, we check the head of Term. if it is a q, then a quote is starting.</span>
<span style="color: #5B6268;"> we check if there is a matching q using the end_q_exists predicate defined below.</span>
<span style="color: #5B6268;"> we then recurse on the tail of Term, and also Qfound, the third argument is now</span>
<span style="color: #5B6268;"> true. We also add q to the output.</span>

<span style="color: #5B6268;"> if a q is found, but no end q exists, everything after it is subject to the</span>
<span style="color: #5B6268;"> substitution rules we defined, so we recurse on the rest of Term</span>
<span style="color: #5B6268;"> We also add q to the output</span>

<span style="color: #5B6268;"> if a q is found, and Qfound is true, then we found the end of a quote</span>
<span style="color: #5B6268;"> we recurse on the tail of Term, and also Qfound is now false</span>
<span style="color: #5B6268;"> We also add q to the output</span>

<span style="color: #5B6268;"> if an e is found, and Qfound is false, then we are not in a quote and should</span>
<span style="color: #5B6268;"> drop the e. We recurse on the tail of Term without adding e to the output.</span>

<span style="color: #5B6268;"> if we find any character that is not q inside a quote, we leave it untouched</span>
<span style="color: #5B6268;"> and recurse on the tail of Term. That atom is added to the output.</span>

<span style="color: #5B6268;"> if we find any character that is not q or e outside a quote, we change it to c</span>
<span style="color: #5B6268;"> and recurse on the tail of Term. c is added to the output.</span>
<span style="color: #5B6268;">*/</span>
<span style="color: #c678dd;">convertHelper</span>(<span style="color: #51afef;">[]</span>, <span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>).
<span style="color: #c678dd;">convertHelper</span>(<span style="color: #51afef;">[</span>q <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span>q <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Output</span><span style="color: #51afef;">]</span>, false) :-
  end_q_exists(<span style="color: #dcaeea;">R</span>),
  convertHelper(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">Output</span>, true).
<span style="color: #c678dd;">convertHelper</span>(<span style="color: #51afef;">[</span>q <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span>q <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Output</span><span style="color: #51afef;">]</span>, false) :-
  \+ end_q_exists(<span style="color: #dcaeea;">R</span>),
  convertHelper(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">Output</span>, false).
<span style="color: #c678dd;">convertHelper</span>(<span style="color: #51afef;">[</span>q <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span>q <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Output</span><span style="color: #51afef;">]</span>, true) :-
  convertHelper(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">Output</span>, false).
<span style="color: #c678dd;">convertHelper</span>(<span style="color: #51afef;">[</span>e <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">Output</span>, false) :-
  convertHelper(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">Output</span>, false).
<span style="color: #c678dd;">convertHelper</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">X</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">X</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Output</span><span style="color: #51afef;">]</span>, true) :-
  <span style="color: #dcaeea;">X</span> \= q,
  convertHelper(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">Output</span>, true).
<span style="color: #c678dd;">convertHelper</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">X</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span>c <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Output</span><span style="color: #51afef;">]</span>, false) :-
  <span style="color: #dcaeea;">X</span> \= q,
  <span style="color: #dcaeea;">X</span> \= e,
  convertHelper(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">Output</span>, false).

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">end_q_exists(+L)</span>
<span style="color: #5B6268;"> this takes in a list of atoms, and is true if there is a q atom in the list</span>
<span style="color: #5B6268;"> it assumes that the first q in the list is already removed</span>
<span style="color: #5B6268;"> (otherwise it would always return true!)</span>

<span style="color: #5B6268;"> How it works:</span>
<span style="color: #5B6268;"> if q is found, true is returned, else, we recurse on the tail of L</span>
<span style="color: #5B6268;"> */</span>
<span style="color: #c678dd;">end_q_exists</span>(<span style="color: #51afef;">[</span>q <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span>).
<span style="color: #c678dd;">end_q_exists</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">X</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>) :-
  <span style="color: #dcaeea;">X</span> \= q,
  end_q_exists(<span style="color: #dcaeea;">R</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">SEND + MORE = MONEY problem</span>
<span style="color: #c678dd;">encrypt</span>(<span style="color: #dcaeea;">W1</span>,<span style="color: #dcaeea;">W2</span>,<span style="color: #dcaeea;">W3</span>) :- 
   length(<span style="color: #dcaeea;">W1</span>,<span style="color: #dcaeea;">N</span>),           <span style="color: #5B6268;">% </span><span style="color: #5B6268;">if you need to know the lengths of words</span>
   length(<span style="color: #dcaeea;">W3</span>,<span style="color: #dcaeea;">N1</span>),   
   append(<span style="color: #dcaeea;">W1</span>,<span style="color: #dcaeea;">W2</span>,<span style="color: #dcaeea;">W</span>),
   append(<span style="color: #dcaeea;">W</span>,<span style="color: #dcaeea;">W3</span>,<span style="color: #dcaeea;">L</span>),
   list_to_set(<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">Letters</span>), <span style="color: #5B6268;">% </span><span style="color: #5B6268;">remove duplicates, a predicate in list library</span>
   <span style="color: #51afef;">[</span><span style="color: #dcaeea;">LeadLetter1</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span> = <span style="color: #dcaeea;">W1</span>,   <span style="color: #5B6268;">% </span><span style="color: #5B6268;">identify the leading letter to be set to non-zero</span>
   <span style="color: #51afef;">[</span><span style="color: #dcaeea;">LeadLetter2</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span> = <span style="color: #dcaeea;">W2</span>,
   <span style="color: #51afef;">[</span><span style="color: #dcaeea;">LeadLetter3</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span> = <span style="color: #dcaeea;">W3</span>,
   <span style="color: #51afef;">!</span>,                      <span style="color: #5B6268;">% </span><span style="color: #5B6268;">never need to redo the above</span>
   <span style="color: #dcaeea;">Letters</span> ins <span style="color: #da8548; font-weight: bold;">0</span>..<span style="color: #da8548; font-weight: bold;">9</span>,
   all_distinct(<span style="color: #dcaeea;">Letters</span>),
   <span style="color: #dcaeea;">LeadLetter1</span> #\= <span style="color: #da8548; font-weight: bold;">0</span>,
   <span style="color: #dcaeea;">LeadLetter2</span> #\= <span style="color: #da8548; font-weight: bold;">0</span>,
   <span style="color: #dcaeea;">LeadLetter3</span> #\= <span style="color: #da8548; font-weight: bold;">0</span>,
   digits_to_number(<span style="color: #dcaeea;">W1</span>, <span style="color: #dcaeea;">Sum1</span>),
   digits_to_number(<span style="color: #dcaeea;">W2</span>, <span style="color: #dcaeea;">Sum2</span>),
   digits_to_number(<span style="color: #dcaeea;">W3</span>, <span style="color: #dcaeea;">Sum3</span>),
   <span style="color: #dcaeea;">Sum1</span> + <span style="color: #dcaeea;">Sum2</span> #=  <span style="color: #dcaeea;">Sum3</span>,
   label(<span style="color: #dcaeea;">Letters</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate converts a list of numbers to an</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">actual number, assuming base10. We sum up</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">each number, and multiply by 10 based on its</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">position in the list</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:- begin_tests(digits).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">test(digits) :-</span>
<span style="color: #5B6268;">%  </span><span style="color: #5B6268;">digits_to_number([1,2,3,4,5,6,7,8,9,0], 1234567890).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:-end_tests(digits).</span>
<span style="color: #c678dd;">digits_to_number</span>(<span style="color: #dcaeea;">Digits</span>, <span style="color: #dcaeea;">Number</span>) :-
  digits_to_number(<span style="color: #dcaeea;">Digits</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">Number</span>).
<span style="color: #c678dd;">digits_to_number</span>(<span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">Sum</span>, <span style="color: #dcaeea;">Sum</span>).
<span style="color: #c678dd;">digits_to_number</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">Digit</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Rest</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">Sum</span>, <span style="color: #dcaeea;">Number</span>) :-
  <span style="color: #dcaeea;">PartialSum</span> #= <span style="color: #dcaeea;">Sum</span>*<span style="color: #da8548; font-weight: bold;">10</span> + <span style="color: #dcaeea;">Digit</span>,
  digits_to_number(<span style="color: #dcaeea;">Rest</span>, <span style="color: #dcaeea;">PartialSum</span>, <span style="color: #dcaeea;">Number</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">subsetsum(L, N)</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate takes in a list L, and an integer N,</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">and it determines if there exists a subset of the list such that </span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">the sum is equal to N</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">:-end_tests(subsetsum).</span>
<span style="color: #c678dd;">subsetsum</span>(<span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">N</span>) :-
  same_length(<span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">Coefficients</span>),
  <span style="color: #dcaeea;">Coefficients</span> ins <span style="color: #da8548; font-weight: bold;">0</span>..<span style="color: #da8548; font-weight: bold;">1</span>,
  maplist(applyCoeff, <span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">Coefficients</span>, <span style="color: #dcaeea;">Output</span>),
  sum(<span style="color: #dcaeea;">Output</span>, #=, <span style="color: #dcaeea;">N</span>),
  label(<span style="color: #dcaeea;">Coefficients</span>).

<span style="color: #c678dd;">applyCoeff</span>(<span style="color: #dcaeea;">Coeff</span>, <span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">Y</span>) :- <span style="color: #dcaeea;">Y</span> #= <span style="color: #dcaeea;">Coeff</span> * <span style="color: #dcaeea;">X</span>.

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">assign(W1, W2)</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">given facts about papers and reviewers as defined in the question,</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">(They are of the form): </span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">paper(ID, Co-author1, Co-author2, Subject)</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">reviewer(Name, Subject1, Subject2)</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">this predicate assigns reviewers to the lists W1 and W2,</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">such that  no one reviews their own paper,</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">and also each reviewer must have the subject in their fact</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">No reviewer is assigned more than workLoadAtMost papers,</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">and each paper is assigned to 2 reviewers. </span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">The paper index corresponds to the indices in W1 and W2.</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">For example, The names that appear at index 1 review paper 1.</span>
<span style="color: #5B6268;">% </span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">How it works:</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">Because this is a quite complex problem, we want to restrict the</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">domain as much as possible as soon as possible. </span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">Each reviewer is assigned a number between 0 and the total number of reviewers</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">multiplied by workLoadAtMost times minus one. We do this so that we can use</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">modulo arithmetic and the all_distinct predicate. My initial solution</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">instead generated two lists of numbers and then made sure that no</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">number appeared more than workLoadAtMost times in either, but that</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">was way too slow, which is why we're using the modulo solution here.</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">The domains are generated in the gen_domain predicate defined below</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">Then, we make sure that once we have 2 lists of numbers,</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">that these reviewers satisfy the constraints above using the</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">constrain_paper predicate defined below</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">Finally, we convert the reviewer numbers to the reviewer</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">name using modulo arithmetic. We use maplist with</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">the reviewer_to_int predicate defined below.</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">Test cases:</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This smaller example works almost instantly on my machine</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(1,lily,xxx,ai).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(2,peter,john,database).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(3,ann,xxx,theory).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(4,ken,lily,network).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(5,kris,xxx,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(lily,theory,network).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(john,ai,theory).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(peter,database,network).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(ann,theory,network).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(kris,theory,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(ken,database,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(bill,database,ai).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(jim,theory,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">workLoadAtMost(2).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">?- assign(W1, W2).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">W1 = [john, ken, lily, peter, ken],</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">W2 = [bill, bill, john, ann, jim].</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This larger example takes about a minute to run on my</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">quad core laptop (i7-7700hq)</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(1,lily,xxx,ai).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(2,peter,john,database).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(3,ann,xxx,theory).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(4,ken,lily,network).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(5,kris,xxx,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(6,jim,xxx,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(7,bill,xxx,theory).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(8,bill,lily,ai).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">paper(9,peter,ann,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(lily,theory,network).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(john,ai,theory).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(peter,database,network).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(ann,theory,network).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(kris,theory,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(ken,database,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(bill,database,ai).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(jim,theory,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(kevin,theory,games).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">reviewer(paul,ai,network).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">workLoadAtMost(2).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">?- assign(W1, W2).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">W1 = [john, ken, lily, peter, ken, kris, lily, john, jim],</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">W2 = [bill, bill, kris, ann, jim, kevin, ann, paul, kevin].</span>
<span style="color: #c678dd;">assign</span>(<span style="color: #dcaeea;">W1</span>, <span style="color: #dcaeea;">W2</span>) :-
  papers(<span style="color: #dcaeea;">PaperIDs</span>),
  gen_domain(<span style="color: #dcaeea;">W1</span>, <span style="color: #dcaeea;">W2</span>, <span style="color: #dcaeea;">N1</span>, <span style="color: #dcaeea;">N2</span>),
  append(<span style="color: #dcaeea;">N1</span>, <span style="color: #dcaeea;">N2</span>, <span style="color: #dcaeea;">N</span>),
  all_distinct(<span style="color: #dcaeea;">N</span>),
  maplist(constrain_paper, <span style="color: #dcaeea;">PaperIDs</span>, <span style="color: #dcaeea;">N1</span>, <span style="color: #dcaeea;">N2</span>),
  label(<span style="color: #dcaeea;">N</span>),
  maplist(reviewer_to_int, <span style="color: #dcaeea;">N1</span>, <span style="color: #dcaeea;">W1</span>),
  maplist(reviewer_to_int, <span style="color: #dcaeea;">N2</span>, <span style="color: #dcaeea;">W2</span>).


<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate does a couple things:</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">It makes sure that W1 and W2 are the same length as the number of papers</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">It also makes N1, and N2 which are lists of numbers</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">which will then be converted into reviewer names for W1 and W2.</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">These are also of the same length as the number of papers.</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">The domain for each entry in N1 and N2 is restricted so that</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">it is between 0 and the number of reviewers times workLoadAtMost - 1 times.</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">That way, we can do modulo arithmetic, and all_distinct to assign</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">reviewers to papers. </span>
<span style="color: #c678dd;">gen_domain</span>(<span style="color: #dcaeea;">W1</span>, <span style="color: #dcaeea;">W2</span>, <span style="color: #dcaeea;">N1</span>, <span style="color: #dcaeea;">N2</span>) :-
  count_papers(<span style="color: #dcaeea;">NumPapers</span>),
  count_reviewers(<span style="color: #dcaeea;">NumReviewers</span>),
  workLoadAtMost(<span style="color: #dcaeea;">Max</span>),
  length(<span style="color: #dcaeea;">W1</span>, <span style="color: #dcaeea;">NumPapers</span>),
  length(<span style="color: #dcaeea;">W2</span>, <span style="color: #dcaeea;">NumPapers</span>),
  length(<span style="color: #dcaeea;">N1</span>, <span style="color: #dcaeea;">NumPapers</span>),
  length(<span style="color: #dcaeea;">N2</span>, <span style="color: #dcaeea;">NumPapers</span>),
  <span style="color: #dcaeea;">R</span> is <span style="color: #dcaeea;">NumReviewers</span> * <span style="color: #dcaeea;">Max</span>,
  <span style="color: #dcaeea;">Range</span> is <span style="color: #dcaeea;">R</span> - <span style="color: #da8548; font-weight: bold;">1</span>,
  <span style="color: #dcaeea;">N1</span> ins <span style="color: #da8548; font-weight: bold;">0</span>..<span style="color: #dcaeea;">Range</span>,
  <span style="color: #dcaeea;">N2</span> ins <span style="color: #da8548; font-weight: bold;">0</span>..<span style="color: #dcaeea;">Range</span>.

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate takes in 2 numbers, each corresponding to one reviewers,</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">and it ensures that the constraints defined in the assignment question are</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">satisfied.</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">We check that the first number is less than the second number because it</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">reduces the search space, even though the overall answer would not change.</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">Then, we convert the reviewer numbers to the reviewer names, and make sure</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">that no author is reviewing their own paper, and that the reviewers</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">assigned have that subject area in their definitions</span>
<span style="color: #5B6268;">%</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate is used with maplist in the assignPaper predicate, so</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">that the papers at each index is checked with this predicate.</span>
<span style="color: #c678dd;">constrain_paper</span>(<span style="color: #dcaeea;">Index</span>, <span style="color: #dcaeea;">Rev1Num</span>, <span style="color: #dcaeea;">Rev2Num</span>) :-
  <span style="color: #dcaeea;">Rev1Num</span> #&lt; <span style="color: #dcaeea;">Rev2Num</span>,
  count_reviewers(<span style="color: #dcaeea;">NumReviewers</span>),
  <span style="color: #dcaeea;">Rev1Mod</span> #= <span style="color: #dcaeea;">Rev1Num</span> mod <span style="color: #dcaeea;">NumReviewers</span>,
  <span style="color: #dcaeea;">Rev2Mod</span> #= <span style="color: #dcaeea;">Rev2Num</span> mod <span style="color: #dcaeea;">NumReviewers</span>,
  <span style="color: #dcaeea;">Rev1Mod</span> #&lt; <span style="color: #dcaeea;">Rev2Mod</span>,
  <span style="color: #dcaeea;">Rev1Mod</span> #\= <span style="color: #dcaeea;">Rev2Mod</span>,
  paper(<span style="color: #dcaeea;">Index</span>, <span style="color: #dcaeea;">Author1</span>, <span style="color: #dcaeea;">Author2</span>, <span style="color: #dcaeea;">Subject</span>),
  reviewer_to_int(<span style="color: #dcaeea;">Rev1Num</span>, <span style="color: #dcaeea;">Rev1Name</span>),
  reviewer_to_int(<span style="color: #dcaeea;">Rev2Num</span>, <span style="color: #dcaeea;">Rev2Name</span>),
  reviewer(<span style="color: #dcaeea;">Rev1Name</span>, <span style="color: #dcaeea;">Sub1</span>, <span style="color: #dcaeea;">Sub2</span>),
  reviewer(<span style="color: #dcaeea;">Rev2Name</span>, <span style="color: #dcaeea;">Sub3</span>, <span style="color: #dcaeea;">Sub4</span>),
  <span style="color: #dcaeea;">Author1</span> \= <span style="color: #dcaeea;">Rev1Name</span>, 
  <span style="color: #dcaeea;">Author1</span> \= <span style="color: #dcaeea;">Rev2Name</span>, 
  <span style="color: #dcaeea;">Author2</span> \= <span style="color: #dcaeea;">Rev1Name</span>, 
  <span style="color: #dcaeea;">Author2</span> \= <span style="color: #dcaeea;">Rev2Name</span>,
  one_of_subject(<span style="color: #dcaeea;">Subject</span>, <span style="color: #dcaeea;">Sub1</span>, <span style="color: #dcaeea;">Sub2</span>, <span style="color: #dcaeea;">Sub3</span>, <span style="color: #dcaeea;">Sub4</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate takes a reviewer number, and converts it to a reviewer name</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">Modulo arithmetic is done, because we expanded the range of numbers for</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">reviewers, and multiple numbers need to map to a single reviewer.</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">For example, if there were 10 reviewers, the numbers 1 and 11 would map to the </span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">second reviewer in the list.</span>
<span style="color: #c678dd;">reviewer_to_int</span>(<span style="color: #dcaeea;">Int</span>, <span style="color: #dcaeea;">Name</span>) :-
  reviewers(<span style="color: #dcaeea;">L</span>),
  count_reviewers(<span style="color: #dcaeea;">NumReviewers</span>),
  <span style="color: #dcaeea;">Index</span> #= <span style="color: #dcaeea;">Int</span> mod <span style="color: #dcaeea;">NumReviewers</span>,
  nth0(<span style="color: #dcaeea;">Index</span>, <span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">Name</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate counts how many papers there are</span>
<span style="color: #c678dd;">count_papers</span>(<span style="color: #dcaeea;">Count</span>) :-
  aggregate_all(count, paper(<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>), <span style="color: #dcaeea;">Count</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate counts how many reviewers there are</span>
<span style="color: #c678dd;">count_reviewers</span>(<span style="color: #dcaeea;">Count</span>) :-
  aggregate_all(count, reviewer(<span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">_</span>), <span style="color: #dcaeea;">Count</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate makes L a list of all of the paper IDs</span>
<span style="color: #c678dd;">papers</span>(<span style="color: #dcaeea;">L</span>) :-
  findall(<span style="color: #dcaeea;">ID</span>, paper(<span style="color: #dcaeea;">ID</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">_</span>), <span style="color: #dcaeea;">L</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate makes L a list of all the reviewer names</span>
<span style="color: #c678dd;">reviewers</span>(<span style="color: #dcaeea;">L</span>) :-
  findall(<span style="color: #dcaeea;">R</span>, reviewer(<span style="color: #dcaeea;">R</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">_</span>), <span style="color: #dcaeea;">L</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">This predicate makes sure that both reviewers have the subject in one of</span>
<span style="color: #5B6268;">% </span><span style="color: #5B6268;">their subject fields</span>
<span style="color: #c678dd;">one_of_subject</span>(<span style="color: #dcaeea;">S</span>, <span style="color: #dcaeea;">S1</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">S3</span>, <span style="color: #dcaeea;">_</span>) :-
  <span style="color: #dcaeea;">S</span> = <span style="color: #dcaeea;">S1</span>,
  <span style="color: #dcaeea;">S</span> = <span style="color: #dcaeea;">S3</span>.
<span style="color: #c678dd;">one_of_subject</span>(<span style="color: #dcaeea;">S</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">S2</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">S4</span>) :-
  <span style="color: #dcaeea;">S</span> = <span style="color: #dcaeea;">S2</span>,
  <span style="color: #dcaeea;">S</span> = <span style="color: #dcaeea;">S4</span>.
<span style="color: #c678dd;">one_of_subject</span>(<span style="color: #dcaeea;">S</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">S2</span>, <span style="color: #dcaeea;">S3</span>, <span style="color: #dcaeea;">_</span>) :-
  <span style="color: #dcaeea;">S</span> = <span style="color: #dcaeea;">S2</span>,
  <span style="color: #dcaeea;">S</span> = <span style="color: #dcaeea;">S3</span>.
<span style="color: #c678dd;">one_of_subject</span>(<span style="color: #dcaeea;">S</span>, <span style="color: #dcaeea;">S1</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">S4</span>) :-
  <span style="color: #dcaeea;">S</span> = <span style="color: #dcaeea;">S1</span>,
  <span style="color: #dcaeea;">S</span> = <span style="color: #dcaeea;">S4</span>.

<span style="color: #5B6268;">/*</span>
<span style="color: #5B6268;">The four square problem:</span>
<span style="color: #5B6268;">Given a natural number N, Sol is bound to a list of 4 or fewer numbers</span>
<span style="color: #5B6268;">so that the sum of their squares equals N</span>
<span style="color: #5B6268;">*/</span>

<span style="color: #c678dd;">f_sq</span>(<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">Sol</span>) :-
   length(<span style="color: #dcaeea;">L</span>,<span style="color: #da8548; font-weight: bold;">4</span>),
   <span style="color: #dcaeea;">L</span> ins <span style="color: #da8548; font-weight: bold;">0</span>..<span style="color: #dcaeea;">N</span>,
   constraint0(<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">L</span>),
   label(<span style="color: #dcaeea;">L</span>),
   removeZero(<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">Sol</span>).

<span style="color: #c678dd;">constraint0</span>(<span style="color: #dcaeea;">N</span>,<span style="color: #51afef;">[</span><span style="color: #dcaeea;">S1</span>,<span style="color: #dcaeea;">S2</span>,<span style="color: #dcaeea;">S3</span>,<span style="color: #dcaeea;">S4</span><span style="color: #51afef;">]</span>) :-
   <span style="color: #dcaeea;">N</span> #= <span style="color: #dcaeea;">S1</span>*<span style="color: #dcaeea;">S1</span> + <span style="color: #dcaeea;">S2</span>*<span style="color: #dcaeea;">S2</span> + <span style="color: #dcaeea;">S3</span>*<span style="color: #dcaeea;">S3</span> + <span style="color: #dcaeea;">S4</span>*<span style="color: #dcaeea;">S4</span>,
   <span style="color: #dcaeea;">S1</span> #=&lt; <span style="color: #dcaeea;">S2</span>, <span style="color: #dcaeea;">S2</span> #=&lt; <span style="color: #dcaeea;">S3</span>, <span style="color: #dcaeea;">S3</span> #=&lt; <span style="color: #dcaeea;">S4</span>.
     <span style="color: #5B6268;">% </span><span style="color: #5B6268;">this removes some redundant solutions</span>

<span style="color: #c678dd;">removeZero</span>(<span style="color: #51afef;">[]</span>,<span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">removeZero</span>(<span style="color: #51afef;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>,<span style="color: #dcaeea;">L1</span>) :-
   <span style="color: #51afef;">!</span>,
   removeZero(<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">L1</span>).
<span style="color: #c678dd;">removeZero</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>,<span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">L1</span><span style="color: #51afef;">]</span>) :-
   removeZero(<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">L1</span>).

<span style="color: #5B6268;">% </span><span style="color: #5B6268;">find all solutions.</span>
<span style="color: #c678dd;">fsq_all</span>(<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">L</span>) :- findall(<span style="color: #dcaeea;">Sol</span>,f_sq(<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">Sol</span>),<span style="color: #dcaeea;">L</span>).

<span style="color: #5B6268;">%</span><span style="color: #5B6268;">Given a list L of elements, each of which represents a course and its enrollment, e.g.[cmput325, [john, lily, ken,...]], define a predicate</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">courses_taken(+L,+Name,-Courses)</span>

<span style="color: #c678dd;">courses_taken</span>(<span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">courses_taken</span>(<span style="color: #51afef;">[[</span><span style="color: #dcaeea;">Course</span>, <span style="color: #dcaeea;">List</span><span style="color: #51afef;">]</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">Name</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">Course</span>, <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">Rest</span><span style="color: #51afef;">]</span>) :-
    member(<span style="color: #dcaeea;">Name</span>, <span style="color: #dcaeea;">List</span>),
    <span style="color: #51afef;">!</span>,
    courses_taken(<span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">Name</span>, <span style="color: #dcaeea;">Rest</span>).
<span style="color: #c678dd;">courses_taken</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">_</span> <span style="color: #51afef;">|</span> <span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">Name</span>, <span style="color: #dcaeea;">R</span>) :-
    courses_taken(<span style="color: #dcaeea;">L</span>, <span style="color: #dcaeea;">Name</span>, <span style="color: #dcaeea;">R</span>).
</pre>
</div>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Closed Knight's Tour.</span>

<span style="color: #5B6268;">   Written by Markus Triska (triska@metalevel.at) Nov. 2nd 2009</span>
<span style="color: #5B6268;">   Public domain code.</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>

:- use_module(library(clpfd)).

<span style="color: #c678dd;">n_tour</span>(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">Ts</span>) :-
        length(<span style="color: #dcaeea;">Ts</span>, <span style="color: #dcaeea;">N</span>),
        maplist(same_length(<span style="color: #dcaeea;">Ts</span>), <span style="color: #dcaeea;">Ts</span>),
        append(<span style="color: #dcaeea;">Ts</span>, <span style="color: #dcaeea;">Vs</span>),
        successors(<span style="color: #dcaeea;">Vs</span>, <span style="color: #dcaeea;">N</span>, <span style="color: #da8548; font-weight: bold;">1</span>),
        circuit(<span style="color: #dcaeea;">Vs</span>).

<span style="color: #c678dd;">successors</span>(<span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">_</span>).
<span style="color: #c678dd;">successors</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">V</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Vs</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">K0</span>) :-
        findall(<span style="color: #dcaeea;">Num</span>, n_k_next(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">K0</span>, <span style="color: #dcaeea;">Num</span>), <span style="color: #51afef;">[</span><span style="color: #dcaeea;">Next</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Nexts</span><span style="color: #51afef;">]</span>),
        foldl(num_to_dom, <span style="color: #dcaeea;">Nexts</span>, <span style="color: #dcaeea;">Next</span>, <span style="color: #dcaeea;">Dom</span>),
        <span style="color: #dcaeea;">V</span> in <span style="color: #dcaeea;">Dom</span>,
        <span style="color: #dcaeea;">K1</span> #= <span style="color: #dcaeea;">K0</span> + <span style="color: #da8548; font-weight: bold;">1</span>,
        successors(<span style="color: #dcaeea;">Vs</span>, <span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">K1</span>).

<span style="color: #c678dd;">num_to_dom</span>(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">D0</span>, <span style="color: #dcaeea;">D0</span>\/<span style="color: #dcaeea;">N</span>).

<span style="color: #c678dd;">n_x_y_k</span>(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">Y</span>, <span style="color: #dcaeea;">K</span>) :- <span style="color: #51afef;">[</span><span style="color: #dcaeea;">X</span>,<span style="color: #dcaeea;">Y</span><span style="color: #51afef;">]</span> ins <span style="color: #da8548; font-weight: bold;">1</span>..<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">K</span> #= <span style="color: #dcaeea;">N</span>*(<span style="color: #dcaeea;">Y</span>-<span style="color: #da8548; font-weight: bold;">1</span>) + <span style="color: #dcaeea;">X</span>.

<span style="color: #c678dd;">n_k_next</span>(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">K</span>, <span style="color: #dcaeea;">Next</span>) :-
        n_x_y_k(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">X0</span>, <span style="color: #dcaeea;">Y0</span>, <span style="color: #dcaeea;">K</span>),
        <span style="color: #51afef;">[</span><span style="color: #dcaeea;">DX</span>,<span style="color: #dcaeea;">DY</span><span style="color: #51afef;">]</span> ins -<span style="color: #da8548; font-weight: bold;">2</span> \/ -<span style="color: #da8548; font-weight: bold;">1</span> \/ <span style="color: #da8548; font-weight: bold;">1</span> \/ <span style="color: #da8548; font-weight: bold;">2</span>,
        abs(<span style="color: #dcaeea;">DX</span>) + abs(<span style="color: #dcaeea;">DY</span>) #= <span style="color: #da8548; font-weight: bold;">3</span>,
        <span style="color: #51afef;">[</span><span style="color: #dcaeea;">X</span>,<span style="color: #dcaeea;">Y</span><span style="color: #51afef;">]</span> ins <span style="color: #da8548; font-weight: bold;">1</span>..<span style="color: #dcaeea;">N</span>,
        <span style="color: #dcaeea;">X</span> #= <span style="color: #dcaeea;">X0</span> + <span style="color: #dcaeea;">DX</span>,
        <span style="color: #dcaeea;">Y</span> #= <span style="color: #dcaeea;">Y0</span> + <span style="color: #dcaeea;">DY</span>,
        n_x_y_k(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">X</span>, <span style="color: #dcaeea;">Y</span>, <span style="color: #dcaeea;">Next</span>),
        label(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">DX</span>,<span style="color: #dcaeea;">DY</span><span style="color: #51afef;">]</span>).

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Text display.</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>

<span style="color: #c678dd;">print_tour</span>(<span style="color: #dcaeea;">Ts</span>) :- print_tour(<span style="color: #dcaeea;">Ts</span>, <span style="color: #da8548; font-weight: bold;">3</span>).

<span style="color: #c678dd;">print_tour</span>(<span style="color: #dcaeea;">Ts</span>, <span style="color: #dcaeea;">I</span>) :-
        tour_enumeration(<span style="color: #dcaeea;">Ts</span>, <span style="color: #dcaeea;">Es</span>),
        phrase(format_string(<span style="color: #dcaeea;">Ts</span>, <span style="color: #dcaeea;">I</span>, <span style="color: #dcaeea;">I</span>), <span style="color: #dcaeea;">Fs</span>),
        maplist(format(<span style="color: #dcaeea;">Fs</span>), <span style="color: #dcaeea;">Es</span>).

<span style="color: #c678dd;">format_</span>(<span style="color: #dcaeea;">Fs</span>, <span style="color: #dcaeea;">Args</span>, <span style="color: #dcaeea;">Xs0</span>, <span style="color: #dcaeea;">Xs</span>) :- format(codes(<span style="color: #dcaeea;">Xs0</span>,<span style="color: #dcaeea;">Xs</span>), <span style="color: #dcaeea;">Fs</span>, <span style="color: #dcaeea;">Args</span>).

<span style="color: #c678dd;">format_string</span>(<span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">_</span>) --&gt; <span style="color: #98be65;">"\n"</span>.
<span style="color: #c678dd;">format_string</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">_</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Rest</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">N0</span>, <span style="color: #dcaeea;">I</span>) --&gt; <span style="color: #98be65;">"~t~w~"</span>, call(format_(<span style="color: #98be65;">"~w|"</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">N0</span><span style="color: #51afef;">]</span>)),
        <span style="color: #51afef;">{</span> <span style="color: #dcaeea;">N1</span> #= <span style="color: #dcaeea;">N0</span> + <span style="color: #dcaeea;">I</span> <span style="color: #51afef;">}</span>,
        format_string(<span style="color: #dcaeea;">Rest</span>, <span style="color: #dcaeea;">N1</span>, <span style="color: #dcaeea;">I</span>).

<span style="color: #c678dd;">tour_enumeration</span>(<span style="color: #dcaeea;">Ts</span>, <span style="color: #dcaeea;">Es</span>) :-
        same_length(<span style="color: #dcaeea;">Ts</span>, <span style="color: #dcaeea;">Es</span>),
        maplist(same_length(<span style="color: #dcaeea;">Ts</span>), <span style="color: #dcaeea;">Es</span>),
        append(<span style="color: #dcaeea;">Ts</span>, <span style="color: #dcaeea;">Vs</span>),
        append(<span style="color: #dcaeea;">Es</span>, <span style="color: #dcaeea;">Ls</span>),
        foldl(vs_enumeration(<span style="color: #dcaeea;">Vs</span>, <span style="color: #dcaeea;">Ls</span>), <span style="color: #dcaeea;">Vs</span>, <span style="color: #da8548; font-weight: bold;">1</span>-<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #dcaeea;">_</span>).

<span style="color: #c678dd;">vs_enumeration</span>(<span style="color: #dcaeea;">Vs</span>, <span style="color: #dcaeea;">Ls</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">V0</span>-<span style="color: #dcaeea;">E0</span>, <span style="color: #dcaeea;">V</span>-<span style="color: #dcaeea;">E</span>) :-
        <span style="color: #dcaeea;">E</span> #= <span style="color: #dcaeea;">E0</span> + <span style="color: #da8548; font-weight: bold;">1</span>,
        nth1(<span style="color: #dcaeea;">V0</span>, <span style="color: #dcaeea;">Ls</span>, <span style="color: #dcaeea;">E0</span>),
        nth1(<span style="color: #dcaeea;">V0</span>, <span style="color: #dcaeea;">Vs</span>, <span style="color: #dcaeea;">V</span>).

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Examples:</span>

<span style="color: #5B6268;">   ?- n_tour(N, Ts), maplist(label, Ts).</span>
<span style="color: #5B6268;">   %@ N = 0,</span>
<span style="color: #5B6268;">   %@ Ts = [] ;</span>
<span style="color: #5B6268;">   %@ N = 6,</span>
<span style="color: #5B6268;">   %@ Ts = [[9, 10, 7, 8, 16, 17], ..., , [27, 28, 20|...]] .</span>

<span style="color: #5B6268;">   ?- n_tour(6, Ts), maplist(label, Ts), print_tour(Ts).</span>
<span style="color: #5B6268;">   %@   1 30 25  6  3 32</span>
<span style="color: #5B6268;">   %@  26  7  2 31 24  5</span>
<span style="color: #5B6268;">   %@  29 36 27  4 33 16</span>
<span style="color: #5B6268;">   %@   8 19 34 15 12 23</span>
<span style="color: #5B6268;">   %@  35 28 21 10 17 14</span>
<span style="color: #5B6268;">   %@  20  9 18 13 22 11</span>

<span style="color: #5B6268;">   ?- time((n_tour(8, Ts), append(Ts, Vs), labeling([ff], Vs))).</span>
<span style="color: #5B6268;">   %@ % 4,191,339 inferences, 0.790 CPU in 0.807 seconds (98% CPU, 5305492 Lips)</span>

<span style="color: #5B6268;">   ?- n_tour(8, Ts), append(Ts, Vs), labeling([ff], Vs), print_tour(Ts).</span>
<span style="color: #5B6268;">   %@   1  4 63 28 31 26 19 22</span>
<span style="color: #5B6268;">   %@  62 29  2  5 20 23 32 25</span>
<span style="color: #5B6268;">   %@   3 64 39 30 27 56 21 18</span>
<span style="color: #5B6268;">   %@  38 61  6 53 40 33 24 55</span>
<span style="color: #5B6268;">   %@   7 52 41 34 57 54 17 46</span>
<span style="color: #5B6268;">   %@  60 37  8 49 44 47 14 11</span>
<span style="color: #5B6268;">   %@  51 42 35 58  9 12 45 16</span>
<span style="color: #5B6268;">   %@  36 59 50 43 48 15 10 13</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Magic Hexagon of order 3, solved with CLP(FD) constraints</span>
<span style="color: #5B6268;">   Written 2006 by Markus Triska triska@metalevel.at</span>
<span style="color: #5B6268;">   Public domain code.</span>

<span style="color: #5B6268;">   Place the integers 1,...,19 in the following grid so that the sum</span>
<span style="color: #5B6268;">   of all numbers in a straight line (there are lines of length 3, 4</span>
<span style="color: #5B6268;">   and 5) is equal to 38:</span>

<span style="color: #5B6268;">            A   B   C</span>
<span style="color: #5B6268;">          D   E   F   G</span>
<span style="color: #5B6268;">        H   I   J   K   L</span>
<span style="color: #5B6268;">          M   N   O   P</span>
<span style="color: #5B6268;">            Q   R   S</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>

:- use_module(library(clpfd)).

<span style="color: #c678dd;">sum38</span>(<span style="color: #dcaeea;">Vs</span>) :- sum(<span style="color: #dcaeea;">Vs</span>, #=, <span style="color: #da8548; font-weight: bold;">38</span>).

<span style="color: #c678dd;">magic_hexagon</span>(<span style="color: #dcaeea;">Vs</span>) :-
        <span style="color: #dcaeea;">Vs</span> = <span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span>,<span style="color: #dcaeea;">B</span>,<span style="color: #dcaeea;">C</span>,<span style="color: #dcaeea;">D</span>,<span style="color: #dcaeea;">E</span>,<span style="color: #dcaeea;">F</span>,<span style="color: #dcaeea;">G</span>,<span style="color: #dcaeea;">H</span>,<span style="color: #dcaeea;">I</span>,<span style="color: #dcaeea;">J</span>,<span style="color: #dcaeea;">K</span>,<span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">M</span>,<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">O</span>,<span style="color: #dcaeea;">P</span>,<span style="color: #dcaeea;">Q</span>,<span style="color: #dcaeea;">R</span>,<span style="color: #dcaeea;">S</span><span style="color: #51afef;">]</span>,
        <span style="color: #dcaeea;">Vs</span> ins <span style="color: #da8548; font-weight: bold;">1</span>..<span style="color: #da8548; font-weight: bold;">19</span>,
        all_different(<span style="color: #dcaeea;">Vs</span>),
        maplist(sum38, <span style="color: #51afef;">[[</span><span style="color: #dcaeea;">A</span>,<span style="color: #dcaeea;">B</span>,<span style="color: #dcaeea;">C</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">D</span>,<span style="color: #dcaeea;">E</span>,<span style="color: #dcaeea;">F</span>,<span style="color: #dcaeea;">G</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">H</span>,<span style="color: #dcaeea;">I</span>,<span style="color: #dcaeea;">J</span>,<span style="color: #dcaeea;">K</span>,<span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">M</span>,<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">O</span>,<span style="color: #dcaeea;">P</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">Q</span>,<span style="color: #dcaeea;">R</span>,<span style="color: #dcaeea;">S</span><span style="color: #51afef;">]</span>,
                        <span style="color: #51afef;">[</span><span style="color: #dcaeea;">H</span>,<span style="color: #dcaeea;">D</span>,<span style="color: #dcaeea;">A</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">M</span>,<span style="color: #dcaeea;">I</span>,<span style="color: #dcaeea;">E</span>,<span style="color: #dcaeea;">B</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">Q</span>,<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">J</span>,<span style="color: #dcaeea;">F</span>,<span style="color: #dcaeea;">C</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">R</span>,<span style="color: #dcaeea;">O</span>,<span style="color: #dcaeea;">K</span>,<span style="color: #dcaeea;">G</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">S</span>,<span style="color: #dcaeea;">P</span>,<span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>,
                        <span style="color: #51afef;">[</span><span style="color: #dcaeea;">C</span>,<span style="color: #dcaeea;">G</span>,<span style="color: #dcaeea;">L</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">B</span>,<span style="color: #dcaeea;">F</span>,<span style="color: #dcaeea;">K</span>,<span style="color: #dcaeea;">P</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">A</span>,<span style="color: #dcaeea;">E</span>,<span style="color: #dcaeea;">J</span>,<span style="color: #dcaeea;">O</span>,<span style="color: #dcaeea;">S</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">D</span>,<span style="color: #dcaeea;">I</span>,<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">R</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">H</span>,<span style="color: #dcaeea;">M</span>,<span style="color: #dcaeea;">Q</span><span style="color: #51afef;">]]</span>).

<span style="color: #5B6268;">%</span><span style="color: #5B6268;">?- magic_hexagon(Vs), labeling([ff], Vs).</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">@ Vs = [3, 17, 18, 19, 7, 1, 11, 16, 2, 5, 6, 9, 12, 4, 8, 14, 10, 13, 15] ;</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">@ Vs = [3, 19, 16, 17, 7, 2, 12, 18, 1, 5, 4, 10, 11, 6, 8, 13, 9, 14, 15] .</span>
<span style="color: #5B6268;">%</span><span style="color: #5B6268;">@ etc.</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Magic Square CLP(FD) formulation.</span>
<span style="color: #5B6268;">   Written 2015 by Markus Triska (triska@metalevel.at)</span>
<span style="color: #5B6268;">   Public domain code.</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>

:- use_module(library(clpfd)).

<span style="color: #c678dd;">magic_square</span>(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">Square</span>) :-
        length(<span style="color: #dcaeea;">Square</span>, <span style="color: #dcaeea;">N</span>),
        maplist(same_length(<span style="color: #dcaeea;">Square</span>), <span style="color: #dcaeea;">Square</span>),
        append(<span style="color: #dcaeea;">Square</span>, <span style="color: #dcaeea;">Vs</span>),
        <span style="color: #dcaeea;">Sq</span> #= <span style="color: #dcaeea;">N</span>^<span style="color: #da8548; font-weight: bold;">2</span>,
        <span style="color: #dcaeea;">Vs</span> ins <span style="color: #da8548; font-weight: bold;">1</span>..<span style="color: #dcaeea;">Sq</span>,
        all_different(<span style="color: #dcaeea;">Vs</span>),
        <span style="color: #dcaeea;">Sum</span> #= <span style="color: #dcaeea;">N</span>*(<span style="color: #dcaeea;">Sq</span> + <span style="color: #da8548; font-weight: bold;">1</span>) // <span style="color: #da8548; font-weight: bold;">2</span>,
        maplist(sum_eq(<span style="color: #dcaeea;">Sum</span>), <span style="color: #dcaeea;">Square</span>),
        transpose(<span style="color: #dcaeea;">Square</span>, <span style="color: #dcaeea;">TSquare</span>),
        maplist(sum_eq(<span style="color: #dcaeea;">Sum</span>), <span style="color: #dcaeea;">TSquare</span>),
        square_diagonal(<span style="color: #dcaeea;">Square</span>, <span style="color: #dcaeea;">Ds</span>),
        sum_eq(<span style="color: #dcaeea;">Sum</span>, <span style="color: #dcaeea;">Ds</span>),
        reverse(<span style="color: #dcaeea;">Square</span>, <span style="color: #dcaeea;">RSquare</span>),
        square_diagonal(<span style="color: #dcaeea;">RSquare</span>, <span style="color: #dcaeea;">RDs</span>),
        sum_eq(<span style="color: #dcaeea;">Sum</span>, <span style="color: #dcaeea;">RDs</span>).

<span style="color: #c678dd;">sum_eq</span>(<span style="color: #dcaeea;">Sum</span>, <span style="color: #dcaeea;">List</span>) :- sum(<span style="color: #dcaeea;">List</span>, #=, <span style="color: #dcaeea;">Sum</span>).

<span style="color: #c678dd;">square_diagonal</span>(<span style="color: #dcaeea;">Rows</span>, <span style="color: #dcaeea;">Ds</span>) :- foldl(diagonal, <span style="color: #dcaeea;">Rows</span>, <span style="color: #dcaeea;">Ds</span>, <span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>).

<span style="color: #c678dd;">diagonal</span>(<span style="color: #dcaeea;">Row</span>, <span style="color: #dcaeea;">D</span>, <span style="color: #dcaeea;">Prefix0</span>, <span style="color: #dcaeea;">Prefix</span>) :-
        append(<span style="color: #dcaeea;">Prefix0</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">D</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">Row</span>),
        same_length(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">_</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Prefix0</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">Prefix</span>).

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Examples:</span>

<span style="color: #5B6268;">   ?- magic_square(N, S), append(S, Vs), label(Vs), maplist(writeln, S).</span>
<span style="color: #5B6268;">   %@ N = 0,</span>
<span style="color: #5B6268;">   %@ S = Vs, Vs = [] ;</span>
<span style="color: #5B6268;">   %@ [1]</span>
<span style="color: #5B6268;">   %@ N = 1,</span>
<span style="color: #5B6268;">   %@ S = [[1]],</span>
<span style="color: #5B6268;">   %@ Vs = [1] ;</span>
<span style="color: #5B6268;">   %@ [2,7,6]</span>
<span style="color: #5B6268;">   %@ [9,5,1]</span>
<span style="color: #5B6268;">   %@ [4,3,8]</span>
<span style="color: #5B6268;">   %@ N = 3,</span>
<span style="color: #5B6268;">   %@ S = [[2, 7, 6], [9, 5, 1], [4, 3, 8]],</span>
<span style="color: #5B6268;">   %@ Vs = [2, 7, 6, 9, 5, 1, 4, 3, 8] .</span>

<span style="color: #5B6268;">   ?- magic_square(4, S), append(S, Vs), label(Vs), maplist(writeln, S).</span>
<span style="color: #5B6268;">   %@ [1,2,15,16]</span>
<span style="color: #5B6268;">   %@ [12,14,3,5]</span>
<span style="color: #5B6268;">   %@ [13,7,10,4]</span>
<span style="color: #5B6268;">   %@ [8,11,6,9]</span>
<span style="color: #5B6268;">   %@ S = [[1, 2, 15, 16], [12, 14, 3, 5], [13, 7, 10, 4], [8, 11, 6, 9]],</span>
<span style="color: #5B6268;">   %@ Vs = [1, 2, 15, 16, 12, 14, 3, 5, 13|...] .</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Relation between a natural number N and its factorial F.</span>

<span style="color: #5B6268;">   CLP(FD) constraints allow for a concise declarative solution that</span>
<span style="color: #5B6268;">   can be used in all directions.</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>

:- use_module(library(clpfd)).

<span style="color: #c678dd;">n_factorial</span>(<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>).
<span style="color: #c678dd;">n_factorial</span>(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">F</span>) :-
        <span style="color: #dcaeea;">N</span> #&gt; <span style="color: #da8548; font-weight: bold;">0</span>,
        <span style="color: #dcaeea;">N1</span> #= <span style="color: #dcaeea;">N</span> - <span style="color: #da8548; font-weight: bold;">1</span>,
        <span style="color: #dcaeea;">F</span> #= <span style="color: #dcaeea;">N</span> * <span style="color: #dcaeea;">F1</span>,
        n_factorial(<span style="color: #dcaeea;">N1</span>, <span style="color: #dcaeea;">F1</span>).

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Examples:</span>

<span style="color: #5B6268;">   ?- n_factorial(47, F).</span>
<span style="color: #5B6268;">   %@ F = 258623241511168180642964355153611979969197632389120000000000 ;</span>
<span style="color: #5B6268;">   %@ false.</span>

<span style="color: #5B6268;">   ?- n_factorial(N, 1).</span>
<span style="color: #5B6268;">   %@ N = 0 ;</span>
<span style="color: #5B6268;">   %@ N = 1 ;</span>
<span style="color: #5B6268;">   %@ false.</span>

<span style="color: #5B6268;">   ?- n_factorial(N, F).</span>
<span style="color: #5B6268;">   %@ N = 0,</span>
<span style="color: #5B6268;">   %@ F = 1 ;</span>
<span style="color: #5B6268;">   %@ N = F, F = 1 ;</span>
<span style="color: #5B6268;">   %@ N = F, F = 2 ;</span>
<span style="color: #5B6268;">   %@ N = 3,</span>
<span style="color: #5B6268;">   %@ F = 6 .</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   N Queens.</span>

<span style="color: #5B6268;">   Written Feb. 2008 by Markus Triska (triska@metalevel.at)</span>
<span style="color: #5B6268;">   Public domain code.</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>

:- use_module(library(clpfd)).

<span style="color: #c678dd;">n_queens</span>(<span style="color: #dcaeea;">N</span>, <span style="color: #dcaeea;">Qs</span>) :-
        length(<span style="color: #dcaeea;">Qs</span>, <span style="color: #dcaeea;">N</span>),
        <span style="color: #dcaeea;">Qs</span> ins <span style="color: #da8548; font-weight: bold;">1</span>..<span style="color: #dcaeea;">N</span>,
        safe_queens(<span style="color: #dcaeea;">Qs</span>).

<span style="color: #c678dd;">safe_queens</span>(<span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">safe_queens</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">Q</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Qs</span><span style="color: #51afef;">]</span>) :- safe_queens(<span style="color: #dcaeea;">Qs</span>, <span style="color: #dcaeea;">Q</span>, <span style="color: #da8548; font-weight: bold;">1</span>), safe_queens(<span style="color: #dcaeea;">Qs</span>).

<span style="color: #c678dd;">safe_queens</span>(<span style="color: #51afef;">[]</span>, <span style="color: #dcaeea;">_</span>, <span style="color: #dcaeea;">_</span>).
<span style="color: #c678dd;">safe_queens</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">Q</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Qs</span><span style="color: #51afef;">]</span>, <span style="color: #dcaeea;">Q0</span>, <span style="color: #dcaeea;">D0</span>) :-
        <span style="color: #dcaeea;">Q0</span> #\= <span style="color: #dcaeea;">Q</span>,
        abs(<span style="color: #dcaeea;">Q0</span> - <span style="color: #dcaeea;">Q</span>) #\= <span style="color: #dcaeea;">D0</span>,
        <span style="color: #dcaeea;">D1</span> #= <span style="color: #dcaeea;">D0</span> + <span style="color: #da8548; font-weight: bold;">1</span>,
        safe_queens(<span style="color: #dcaeea;">Qs</span>, <span style="color: #dcaeea;">Q0</span>, <span style="color: #dcaeea;">D1</span>).


<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Examples:</span>

<span style="color: #5B6268;">   ?- n_queens(8, Qs), labeling([ff], Qs).</span>
<span style="color: #5B6268;">   %@ Qs = [1, 5, 8, 6, 3, 7, 2, 4] ;</span>
<span style="color: #5B6268;">   %@ Qs = [1, 6, 8, 3, 7, 4, 2, 5] .</span>

<span style="color: #5B6268;">   ?- n_queens(100, Qs), labeling([ff], Qs).</span>
<span style="color: #5B6268;">   %@ Qs = [1, 3, 5, 57, 59, 4, 64, 7, 58|...] .</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Cryptoarithmetic puzzle: Assign one of the digits 0,..,9 to each of</span>
<span style="color: #5B6268;">   the letters S,E,N,D,M,O,R and Y in such a way that the following</span>
<span style="color: #5B6268;">   calculation is valid, and no leading zeroes appear.</span>

<span style="color: #5B6268;">   Written 2007 by Markus Triska (triska@metalevel.at)</span>
<span style="color: #5B6268;">   Public domain code.</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>

:- use_module(library(clpfd)).

<span style="color: #c678dd;">puzzle</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">S</span>,<span style="color: #dcaeea;">E</span>,<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">D</span><span style="color: #51afef;">]</span> + <span style="color: #51afef;">[</span><span style="color: #dcaeea;">M</span>,<span style="color: #dcaeea;">O</span>,<span style="color: #dcaeea;">R</span>,<span style="color: #dcaeea;">E</span><span style="color: #51afef;">]</span> = <span style="color: #51afef;">[</span><span style="color: #dcaeea;">M</span>,<span style="color: #dcaeea;">O</span>,<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">E</span>,<span style="color: #dcaeea;">Y</span><span style="color: #51afef;">]</span>) :-
        <span style="color: #dcaeea;">Vars</span> = <span style="color: #51afef;">[</span><span style="color: #dcaeea;">S</span>,<span style="color: #dcaeea;">E</span>,<span style="color: #dcaeea;">N</span>,<span style="color: #dcaeea;">D</span>,<span style="color: #dcaeea;">M</span>,<span style="color: #dcaeea;">O</span>,<span style="color: #dcaeea;">R</span>,<span style="color: #dcaeea;">Y</span><span style="color: #51afef;">]</span>,
        <span style="color: #dcaeea;">Vars</span> ins <span style="color: #da8548; font-weight: bold;">0</span>..<span style="color: #da8548; font-weight: bold;">9</span>,
        all_different(<span style="color: #dcaeea;">Vars</span>),
                  <span style="color: #dcaeea;">S</span>*<span style="color: #da8548; font-weight: bold;">1000</span> + <span style="color: #dcaeea;">E</span>*<span style="color: #da8548; font-weight: bold;">100</span> + <span style="color: #dcaeea;">N</span>*<span style="color: #da8548; font-weight: bold;">10</span> + <span style="color: #dcaeea;">D</span> +
                  <span style="color: #dcaeea;">M</span>*<span style="color: #da8548; font-weight: bold;">1000</span> + <span style="color: #dcaeea;">O</span>*<span style="color: #da8548; font-weight: bold;">100</span> + <span style="color: #dcaeea;">R</span>*<span style="color: #da8548; font-weight: bold;">10</span> + <span style="color: #dcaeea;">E</span> #=
        <span style="color: #dcaeea;">M</span>*<span style="color: #da8548; font-weight: bold;">10000</span> + <span style="color: #dcaeea;">O</span>*<span style="color: #da8548; font-weight: bold;">1000</span> + <span style="color: #dcaeea;">N</span>*<span style="color: #da8548; font-weight: bold;">100</span> + <span style="color: #dcaeea;">E</span>*<span style="color: #da8548; font-weight: bold;">10</span> + <span style="color: #dcaeea;">Y</span>,
        <span style="color: #dcaeea;">M</span> #\= <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">S</span> #\= <span style="color: #da8548; font-weight: bold;">0</span>.

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Examples:</span>

<span style="color: #5B6268;">   ?- puzzle(As+Bs=Cs).</span>
<span style="color: #5B6268;">   %@ As = [9, X1, X2, X3],</span>
<span style="color: #5B6268;">   %@ Bs = [1, 0, X4, X1],</span>
<span style="color: #5B6268;">   %@ Cs = [1, 0, X2, X1, X5],</span>
<span style="color: #5B6268;">   %@ X1 in 4..7,</span>
<span style="color: #5B6268;">   %@ all_different([9, X1, X2, X3, 1, 0, X4, X5]),</span>
<span style="color: #5B6268;">   %@ 91*X1+X3+10*X4#=90*X2+X5,</span>
<span style="color: #5B6268;">   %@ X2 in 5..8,</span>
<span style="color: #5B6268;">   %@ X3 in 2..8,</span>
<span style="color: #5B6268;">   %@ X4 in 2..8,</span>
<span style="color: #5B6268;">   %@ X5 in 2..8.</span>

<span style="color: #5B6268;">   ?- puzzle(As+Bs=Cs), label(As).</span>
<span style="color: #5B6268;">   %@ As = [9, 5, 6, 7],</span>
<span style="color: #5B6268;">   %@ Bs = [1, 0, 8, 5],</span>
<span style="color: #5B6268;">   %@ Cs = [1, 0, 6, 5, 2] ;</span>
<span style="color: #5B6268;">   %@ false.</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Sudoku CLP(FD) formulation.</span>

<span style="color: #5B6268;">   Written Feb. 2008 by Markus Triska  (triska@metalevel.at)</span>
<span style="color: #5B6268;">   Public domain code.</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>

:- use_module(library(clpfd)).

<span style="color: #c678dd;">sudoku</span>(<span style="color: #dcaeea;">Rows</span>) :-
        length(<span style="color: #dcaeea;">Rows</span>, <span style="color: #da8548; font-weight: bold;">9</span>), maplist(same_length(<span style="color: #dcaeea;">Rows</span>), <span style="color: #dcaeea;">Rows</span>),
        append(<span style="color: #dcaeea;">Rows</span>, <span style="color: #dcaeea;">Vs</span>), <span style="color: #dcaeea;">Vs</span> ins <span style="color: #da8548; font-weight: bold;">1</span>..<span style="color: #da8548; font-weight: bold;">9</span>,
        maplist(all_distinct, <span style="color: #dcaeea;">Rows</span>),
        transpose(<span style="color: #dcaeea;">Rows</span>, <span style="color: #dcaeea;">Columns</span>), maplist(all_distinct, <span style="color: #dcaeea;">Columns</span>),
        <span style="color: #dcaeea;">Rows</span> = <span style="color: #51afef;">[</span><span style="color: #dcaeea;">As</span>,<span style="color: #dcaeea;">Bs</span>,<span style="color: #dcaeea;">Cs</span>,<span style="color: #dcaeea;">Ds</span>,<span style="color: #dcaeea;">Es</span>,<span style="color: #dcaeea;">Fs</span>,<span style="color: #dcaeea;">Gs</span>,<span style="color: #dcaeea;">Hs</span>,<span style="color: #dcaeea;">Is</span><span style="color: #51afef;">]</span>,
        blocks(<span style="color: #dcaeea;">As</span>, <span style="color: #dcaeea;">Bs</span>, <span style="color: #dcaeea;">Cs</span>), blocks(<span style="color: #dcaeea;">Ds</span>, <span style="color: #dcaeea;">Es</span>, <span style="color: #dcaeea;">Fs</span>), blocks(<span style="color: #dcaeea;">Gs</span>, <span style="color: #dcaeea;">Hs</span>, <span style="color: #dcaeea;">Is</span>).

<span style="color: #c678dd;">blocks</span>(<span style="color: #51afef;">[]</span>, <span style="color: #51afef;">[]</span>, <span style="color: #51afef;">[]</span>).
<span style="color: #c678dd;">blocks</span>(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">N1</span>,<span style="color: #dcaeea;">N2</span>,<span style="color: #dcaeea;">N3</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Ns1</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">N4</span>,<span style="color: #dcaeea;">N5</span>,<span style="color: #dcaeea;">N6</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Ns2</span><span style="color: #51afef;">]</span>, <span style="color: #51afef;">[</span><span style="color: #dcaeea;">N7</span>,<span style="color: #dcaeea;">N8</span>,<span style="color: #dcaeea;">N9</span><span style="color: #51afef;">|</span><span style="color: #dcaeea;">Ns3</span><span style="color: #51afef;">]</span>) :-
        all_distinct(<span style="color: #51afef;">[</span><span style="color: #dcaeea;">N1</span>,<span style="color: #dcaeea;">N2</span>,<span style="color: #dcaeea;">N3</span>,<span style="color: #dcaeea;">N4</span>,<span style="color: #dcaeea;">N5</span>,<span style="color: #dcaeea;">N6</span>,<span style="color: #dcaeea;">N7</span>,<span style="color: #dcaeea;">N8</span>,<span style="color: #dcaeea;">N9</span><span style="color: #51afef;">]</span>),
        blocks(<span style="color: #dcaeea;">Ns1</span>, <span style="color: #dcaeea;">Ns2</span>, <span style="color: #dcaeea;">Ns3</span>).

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Sample problems.</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>

<span style="color: #c678dd;">problem</span>(<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #dcaeea;">P</span>) :-
        <span style="color: #dcaeea;">P</span> = <span style="color: #51afef;">[[</span><span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">8</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">4</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span>,
             <span style="color: #51afef;">[</span><span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">4</span>,<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #da8548; font-weight: bold;">6</span><span style="color: #51afef;">]</span>,
             <span style="color: #51afef;">[</span><span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span>,
             <span style="color: #51afef;">[</span><span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">4</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">8</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">5</span><span style="color: #51afef;">]</span>,
             <span style="color: #51afef;">[</span><span style="color: #da8548; font-weight: bold;">7</span>,<span style="color: #da8548; font-weight: bold;">8</span>,<span style="color: #da8548; font-weight: bold;">9</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span>,
             <span style="color: #51afef;">[</span><span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">6</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">3</span><span style="color: #51afef;">]</span>,
             <span style="color: #51afef;">[</span><span style="color: #da8548; font-weight: bold;">8</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">7</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span>,
             <span style="color: #51afef;">[</span><span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">8</span>,<span style="color: #dcaeea;">_</span><span style="color: #51afef;">]</span>,
             <span style="color: #51afef;">[</span><span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">9</span><span style="color: #51afef;">]]</span>.

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Example:</span>

<span style="color: #5B6268;">   ?- problem(1, Rows), sudoku(Rows),</span>
<span style="color: #5B6268;">      maplist(labeling([ff]), Rows), maplist(writeln, Rows).</span>
<span style="color: #5B6268;">   %@ [1,5,6,8,9,4,3,2,7]</span>
<span style="color: #5B6268;">   %@ [9,2,8,7,3,1,4,5,6]</span>
<span style="color: #5B6268;">   %@ [4,7,3,2,6,5,9,1,8]</span>
<span style="color: #5B6268;">   %@ [3,6,2,4,1,7,8,9,5]</span>
<span style="color: #5B6268;">   %@ [7,8,9,3,5,2,6,4,1]</span>
<span style="color: #5B6268;">   %@ [5,1,4,9,8,6,2,7,3]</span>
<span style="color: #5B6268;">   %@ [8,3,1,5,4,9,7,6,2]</span>
<span style="color: #5B6268;">   %@ [6,9,7,1,2,3,5,8,4]</span>
<span style="color: #5B6268;">   %@ [2,4,5,6,7,8,1,3,9]</span>
<span style="color: #5B6268;">   %@ Rows = [[1, 5, 6, 8, 9, 4, 3, 2|...], [9, 2, 8, 7, 3, 1, 4|...], [4, 7, 3, 2, 6, 5|...], [3, 6, 2, 4, 1|...], [7, 8, 9, 3|...], [5, 1, 4|...], [8, 3|...], [6|...], [...|...]].</span>

<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   Task scheduling example.</span>

<span style="color: #5B6268;">   Written May 2016 by Markus Triska (triska@metalevel.at)</span>
<span style="color: #5B6268;">   Public domain code.</span>

<span style="color: #5B6268;">   The </span><span style="color: #c678dd;">cumulative/2</span><span style="color: #5B6268;"> constraint is used to express non-overlapping</span>
<span style="color: #5B6268;">   tasks with a resource consumption limit. The </span><span style="color: #c678dd;">min/1</span><span style="color: #5B6268;"> labeling option</span>
<span style="color: #5B6268;">   is used to find schedules that minimize the total duration.</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>

:- use_module(library(clpfd)).

<span style="color: #c678dd;">tasks</span>(<span style="color: #dcaeea;">Tasks</span>, <span style="color: #dcaeea;">Starts</span>, <span style="color: #dcaeea;">End</span>) :-
        <span style="color: #dcaeea;">Tasks</span> = <span style="color: #51afef;">[</span>task(<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #dcaeea;">_</span>),
                 task(<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">4</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #dcaeea;">_</span>),
                 task(<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #dcaeea;">_</span>),
                 task(<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #dcaeea;">_</span>)<span style="color: #51afef;">]</span>,
        maplist(task_start, <span style="color: #dcaeea;">Tasks</span>, <span style="color: #dcaeea;">Starts</span>),
        <span style="color: #dcaeea;">Starts</span> ins <span style="color: #da8548; font-weight: bold;">0</span>..<span style="color: #da8548; font-weight: bold;">100</span>,
        cumulative(<span style="color: #dcaeea;">Tasks</span>, <span style="color: #51afef;">[</span>limit(<span style="color: #da8548; font-weight: bold;">2</span>)<span style="color: #51afef;">]</span>),
        foldl(max_end, <span style="color: #dcaeea;">Tasks</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">End</span>).

<span style="color: #c678dd;">task_start</span>(task(<span style="color: #dcaeea;">Start</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>), <span style="color: #dcaeea;">Start</span>).

<span style="color: #c678dd;">max_end</span>(task(<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">End</span>,<span style="color: #dcaeea;">_</span>,<span style="color: #dcaeea;">_</span>), <span style="color: #dcaeea;">E0</span>, <span style="color: #dcaeea;">E</span>) :-
        <span style="color: #dcaeea;">E</span> #= max(<span style="color: #dcaeea;">E0</span>, <span style="color: #dcaeea;">End</span>).

<span style="color: #5B6268;">/* </span><span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span style="color: #5B6268;">   ?- tasks(Tasks, Starts, End), labeling([min(End)], Starts).</span>
<span style="color: #5B6268;">   %@ Tasks = [task(0, 3, 3, 1, _G32), task(0, 4, 4, 1, _G41), task(4, 2, 6, 1, _G50), task(3, 3, 6, 1, _G59)],</span>
<span style="color: #5B6268;">   %@ Starts = [0, 0, 4, 3],</span>
<span style="color: #5B6268;">   %@ End = 6 .</span>
<span style="color: #5B6268;">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgce308f6" class="outline-4">
<h4 id="orgce308f6"><span class="section-number-4">2.1.2</span> True/False</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>(true ) prolog&rsquo;s backtracking is useful for a CLP solver</li>
<li>(false) CLP is more general than logic programming</li>
<li>(false) all variable sin a constraint problem have the same domain</li>
<li>(true ) a constraint problem can be solved with C or Java</li>
<li>(true ) current CLP systems are useful for industrial applications</li>
<li>(false) a problem with 2 contradictory constraints can still have a solution</li>
<li>(false) CLP is designed to replace all previous forms of logic programming</li>
<li>(true ) CLP can be 1 million times more efficient than prolog backtracking</li>
<li>(false) CLPFD contains one fixed strategy for assigning values to variables</li>
<li>(true ) Using Prolog&rsquo;s negation operator can lead to non-logical results, especially when the query has free variables</li>
<li>(false) In logic programming, function symbols are used only for creating data structures, not for expressing computation.</li>
<li>(true ) Constraint programming can solve more problems in a declarative way than pure Prolog</li>
<li>(false) The handling of inequalities is the same in pure Prolog and in constraint programming</li>
<li>(true ) Node consistency reduces the domain of a single variable.</li>
<li>(true ) Arc consistency can reduce the domains of two variables by considering constraints between them.</li>
<li>(true ) Sometimes, node and arc consistency can be applied repeatedly to different sets of variables to reduce the domains even further.</li>
<li>(false)  In SWI Prolog with CLP(FD), the domains of variables have to be consecutive integers.
must be integer, but no need to be consecutive</li>
<li>(true ) Some problems can be solved by pure constraint propagation, with no search.</li>
<li>(false) When writing a CLP(FD) program, the order of specifying the constraints vs calling labeling does not matter.
constraints need to be applied first</li>
<li>(false) CLP(FD) is a nice formalism, but there is always a Prolog program of similar length that is just as efficent</li>
<li>(true ) In SWI Prolog&rsquo;s CLP(FD), a constraint can contain an arithmetic expression on the left hand side, as in 2 * X + 3 #&gt; 5.</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org12cf9e9" class="outline-3">
<h3 id="org12cf9e9"><span class="section-number-3">2.2</span> Foundations of logic programming</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li><a href="https://eclass.srv.ualberta.ca/pluginfile.php/6714438/mod_resource/content/9/logic-foundations.pdf">https://eclass.srv.ualberta.ca/pluginfile.php/6714438/mod_resource/content/9/logic-foundations.pdf</a></li>
<li id="Herbrand universe">The set of all ground terms</li>
</ul>
</div>
<div id="outline-container-org62505d4" class="outline-4">
<h4 id="org62505d4"><span class="section-number-4">2.2.1</span> True/false</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Let P be a program consisting of Horn clauses,
let H be its Herbrand universe, and
let B be the Herbrand base of P.
Let the minus sign ‘-’ stand for logical negation
</p>
<ul class="org-ul">
<li>(false) A Horn clause has at most one negative literal</li>
<li>(false) p→ (a ∨ b) is a Horn clause</li>
<li>(true ) (a ∨ b) → p is a Horn clause</li>
<li>(true ) an atom is a literal</li>
<li>(true ) a negated atom is a literal</li>
<li>(true ) any subset of B is an interpretation of P</li>
<li>(true ) B is a model of P</li>
<li>(false) the empty set is always a model of P</li>
<li>(true ) -∀x p(x)  is logically equivalent to ∃x -p(x)</li>
<li>(true ) In propositional logic, we can always check whether a formula is a logical consequence of other formulas by building a truth table.</li>
<li>(false) The size of a truth table grows exponentially with the number of formulas.
it grows exponentially with the number of variables</li>
<li>(false) In a Horn clause, the head of a clause can be a list of predicates.
the head can only be a single predicate</li>
<li>(false) A ground atom can contain variables, but only those from the Herbrand Universe.
<ul class="org-ul">
<li>A ground atom cannot contain variables</li>
<li>The herbrand universe does not contain any variables</li>
</ul></li>
<li>(false) The Herbrand Universe of a program is always infinite
Only infinite if there are no functions</li>
<li>(false) The Herbrand Universe is a subset of the Herbrand Base
<ul class="org-ul">
<li>the base consists of ground atoms (predicates with ground arguments)</li>
<li>the usiverse consists of ground terms (build from constraints and functions)</li>
</ul></li>
<li>(true ) A model of a program P contains all the atoms from the least model of P.
<ul class="org-ul">
<li>A model is consistent with the program, so it must contain all the logical consequences of P.</li>
<li>The least model consists exactly of those consequences</li>
</ul></li>
<li>(true ) The iterative algorithm for computing the least model will terminate if and only if the least model is finite</li>
<li>(true ) A Prolog program can only prove those facts which are in the least model.</li>
<li>(false ) A depth-first Prolog search is always more efficient than the breadth-first style iterative computation of the least model
It is usually much more efficient, but prolog could get stuck in an infinite loop while the least model would
find all paths in finite time</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgb0beefc" class="outline-3">
<h3 id="orgb0beefc"><span class="section-number-3">2.3</span> Constraint logic programming</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li><a href="https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830070">https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830070</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgad591da" class="outline-3">
<h3 id="orgad591da"><span class="section-number-3">2.4</span> Constraint satisfaction problem</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li><a href="https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830065">https://eclass.srv.ualberta.ca/mod/page/view.php?id=4830065</a></li>
<li>3 ingredients
<ol class="org-ol">
<li>Variables</li>
<li>domains</li>
<li>constraints</li>
</ol></li>
<li id="constraint store">a collection of the primitive constraints, decomposed from user specified constraints.
it is checked at runtime for consistency whenever the state of these constraints is changed
(like when a variable is assigned a value)</li>
</ul>
</div>
</div>

<div id="outline-container-orgf8349f6" class="outline-3">
<h3 id="orgf8349f6"><span class="section-number-3">2.5</span> Answer set Programming</h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-org53a4c67" class="outline-4">
<h4 id="org53a4c67"><span class="section-number-4">2.5.1</span> Syntax</h4>
<div class="outline-text-4" id="text-2-5-1">
<pre class="example" id="org8274dad">
:- is a constraint
you apply things you do NOT want to happen here
i.e. if the thing after :- is true, it cannot happen

a ferry cannot be at 2 different locations at the same time
:- at(ferry, Loc, T), at(ferry, Loc1, T), Loc != Loc1.

two different cars cannot board the same location at the same time
:- board(Car1, Loc, T), board(Car2, Loc, T), Car1 != Car2.
</pre>
</div>
</div>
<div id="outline-container-org63bc296" class="outline-4">
<h4 id="org63bc296"><span class="section-number-4">2.5.2</span> Ground vs not ground</h4>
<div class="outline-text-4" id="text-2-5-2">
<dl class="org-dl">
<dt>grounding</dt><dd>the process of translating a non-ground program to a ground one</dd>
<dt>(no term)</dt><dd>if you have variables, it&rsquo;s ground</dd>
<dt>(no term)</dt><dd>if it&rsquo;s the same function, but with concrete numbers/atoms in place of a variable, it&rsquo;s grounded</dd>
</dl>
</div>
</div>

<div id="outline-container-org480e4b1" class="outline-4">
<h4 id="org480e4b1"><span class="section-number-4">2.5.3</span> Problems</h4>
<div class="outline-text-4" id="text-2-5-3">
</div>
<ol class="org-ol">
<li><a id="org2f01250"></a>Elevator problem<br />
<div class="outline-text-5" id="text-2-5-3-1">
<ul class="org-ul">
<li>elevator transports passengers from initial floors to goal floors</li>
<li>when it stops at a floor, any passenger can board or unboard</li>
<li>the goal is to transport all passengers to their destination floors</li>
</ul>
</div>
</li>
<li><a id="org412f40d"></a>Gripper problem<br />
<div class="outline-text-5" id="text-2-5-3-2">
<ul class="org-ul">
<li>transport all the balls from one room to another</li>
<li>robot is allowed to move form one room to the other and use its 2 grippers to pick up and put down balls</li>
</ul>
</div>
</li>
<li><a id="org0206c0a"></a>Blocks world<br />
<div class="outline-text-5" id="text-2-5-3-3">
<ul class="org-ul">
<li>build one or more vertical stacks of blocks</li>
<li>only one block moved at a time</li>
<li>block can be placed on the table or on top of another block</li>
<li>blocks that are under other blocks cannot be moved</li>
</ul>
</div>
</li>
<li><a id="orgfaeb88f"></a>N queens problem<br />
<div class="outline-text-5" id="text-2-5-3-4">
<p>
n<sub>queens</sub> problem
</p>
<div class="org-src-container">
<pre class="src src-asp">#show q/2.
d(1..queens).
1 {q(X,Y):d(Y)} 1 :-d(X).
:- d(X), d(Y), d(X1), q(X,Y), q(X1,Y), X1 != X.
:- d(X), d(Y), d(Y1), q(X,Y), q(X,Y1), Y1 != Y.
% the above is not needed logically
:- d(X), d(Y), d(X1), d(Y1), q(X,Y), q(X1,Y1),
X != X1, Y != Y1, abs(X -X1) == abs(Y -Y1).
:-d(Y), not hasq(Y).
hasq(Y) :-d(X), d(Y), q(X,Y).
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgf231af3" class="outline-4">
<h4 id="orgf231af3"><span class="section-number-4">2.5.4</span> Ferry problem</h4>
<div class="outline-text-4" id="text-2-5-4">
<div class="org-src-container">
<pre class="src src-asp">move(ferry, From, To, Time)
board(Car, Location, Time)
unboard(Car, Location, Time)
at(Object, Location, Time) % object is at Location at Time
in(ferry, Car, T) % Car is in ferry at Time
empty(ferry, T) % ferry is empty at Time
moving(ferry, T) % don't care about location at Time
affected(Object, T) % Object is affected by some action at Time

% constrains

% ferry cannot be moved to 2 different locations at the same time
:- at(ferry, Loc, T), at(ferry, Loc1, T), Loc != Loc1.

% two cars cannot be boarded at the same time and location
:- board(Car1, Loc, T), board(Car2, Loc, T), Car1 != Car2.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-clingo">%Name: Arun Woosaree
%Student Number: 1514457
%Course: CMPUT 325
%Section: B1
%Assignment 4

% Initially, there are cars at various locations, and there is a
% ferry at some location. The ferry can only transport one car at
% a time and the goal is to transport all cars to their
% destinations. No paralell actions are allowed.

#show board/3.
#show move/4.
#show unboard/3.
%#show at/3.
%#show in/3.
%#show moving/3.


time(0..steps).

% Clingo processes "safe programs": any variable occuring in a
% negative literal of rule r must appear in a positive atom in the body of r.
%
% There is nothing wrong to use domains predicates. One may first write
% these predicates and then comment the unnessary ones out (as shown).
% Nothing wrong to leave them there.
% Not all of them can be removed, specially when there is a possibility
% a variable can be instantiated (during grounding) to something unintended.
% You may discover this during debugging using the "#show" diretive.


% actions
{board(Car,Loc,T)} :-
        car(Car),
%       location(Loc), time(T),
        empty(ferry,T),
        at(Car,Loc,T),
        at(ferry,Loc,T),
        not moving(ferry,Loc,T),
        not goal(T).

{unboard(Car,Loc,T)} :-
        car(Car),
%       location(Loc), time(T),
        in(ferry,Car,T),
        at(ferry,Loc,T),
        not moving(ferry,Loc,T),
        not goal(T).

{move(ferry,From,To,T)} :-
%       car(Car),location(From), time(T),
        location(To),
        at(ferry,From,T),
        From != To,
        not goal(T).

moving(ferry,From,T):-     % irrelevant of where ferry moves to
%       location(From),location(Loc), time(T),
        at(ferry,From,T),
        move(ferry,From,Loc,T).

% Below is the wrong code to define empty: it says if there exists
% a Car not in ferry, then ferry is empty.
%
% empty(ferry,T):-
%       car(Car), time(T),
%       not in(ferry,Car,T).

empty(ferry,T):- time(T), not occupied(ferry,T).
occupied(ferry,T) :- in(_,_,T).


%fluents
in(ferry,Car,T+1):-   %an action causes a property to hold
%       car(Car), location(Loc), time(T),
        at(ferry,Loc,T),
        board(Car,Loc,T).

in(ferry,Car,T+1):-
%       car(Car),
        time(T),
        in(ferry,Car,T),
        not affected0(Car,T).

affected0(Car,T) :-
%       time(T), car(Car), location(Loc),
        unboard(Car,Loc,T).

% !!! Cannot replace the above by below - it says that
% Car is in ferry at T+1 if at T there is a location Loc
% s.t. Car is not unboarded - not intended!
%
% in(ferry,Car,T+1):-
%        car(Car), time(T),
%        in(ferry,Car,T),
%        not unboard(Car,Loc,T).

at(ferry,Loc,T+1):-
%       car(Car), location(Loc), time(T),
        at(ferry,Loc,T),
        board(Car,Loc,T).

at(ferry,Loc,T+1):-
%       car(Car), location(Loc), time(T),
        at(ferry,Loc,T),
        unboard(Car,Loc,T).

at(ferry,Loc,T+1):-
%       location(Loc),
        time(T),
        at(ferry,Loc,T), %if we don't have tis line, what could happen?
                         %A: ferry can be everywhere
        not moving(ferry,Loc,T).

at(ferry,To,T+1):-
%       location(To),location(From),
        time(T),
        at(ferry,From,T),
        move(ferry,From,To,T).

at(Car,Loc,T+1):-
        car(Car),  % not commented out - don't want Car instantied to ferry
%       location(Loc), time(T),
        unboard(Car,Loc,T).

at(Car,Loc,T+1):-    %frame axiom
        car(Car), location(Loc), time(T),
        at(Car,Loc,T),
        not board(Car,Loc,T).

goal(T+1):-  time(T), goal(T).
     %once goal is achieved, goal(T) is true for all T &gt; k.

goal :- time(T), goal(T).
:- not goal.


% The code above works for the input file, ferryIn0.lp and ferryIn1.lp,
% but not ferryIn2.lp.
%
% Discover what is wrong. Consider adding the following constraints:
%
% 1. ferry cannot be moved to two different locations at the same time
% 2. it's not possible to board different cars at the same time and same location.

% I think this code is pretty self explanatory
% we add constraints that are exactly as described above

:- at(ferry, Loc, T), at(ferry, Loc1, T), Loc != Loc1.
:- board(Car1, Loc, T), board(Car2, Loc, T), Car1 != Car2.

</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Arun Woosaree</p>
<p class="date">Created: 2021-04-20 Tue 13:11</p>
</div>
</body>
</html>
